太好了！我们现在进入 **Phase 1 的第二个知识单元（KU 1.2）的第一个原子知识点**：**1.2.1 内置类型：bool, char, signed/unsigned char, short, int, long, long long**。

这是 C++ 类型系统的**基石**。与 Java 不同，C++ 的整数类型**不保证跨平台大小**，且区分 **signed/unsigned**，这既是灵活性的来源，也是常见错误的温床。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（类型地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.2.1：内置整数类型

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：KU 1.1（构建模型）  
> **后续衔接**：1.2.2（浮点类型）、1.2.6（size_t）、1.7（C 风格字符串）  
> **预计耗时**：3–4 小时

---

### 🧭 一、结构先行：C++ 内置整数类型地图

```
1.2.1 内置整数类型
├── 1. 布尔类型：bool
├── 2. 字符类型
│   ├── char（平台相关：signed 或 unsigned）
│   ├── signed char
│   └── unsigned char
├── 3. 短整型：short / unsigned short
├── 4. 整型：int / unsigned int
├── 5. 长整型：long / unsigned long
├── 6. 长长整型：long long / unsigned long long（C++11）
└── 7. 关键特性
    ├── 7.1 大小不固定（依赖平台/编译器）
    ├── 7.2 有符号 vs 无符号
    └── 7.3 与 Java 的根本差异
```

> 💡 **核心原则**：  
> **C++ 类型 = 机器友好，Java 类型 = 开发者友好**

---

### 🎯 二、SMART 学习目标

- **Specific**：能正确使用 C++ 内置整数类型，理解其大小、符号性、平台依赖性。
- **Measurable**：完成 3 道基础题 + 2 道陷阱题，能解释 `unsigned` 下溢行为。
- **Achievable**：通过“尺子”比喻理解类型大小差异。
- **Relevant**：这是避免缓冲区溢出、类型转换错误的基础。
- **Time-bound**：2 天内完成。

---

### 🌍 三、生活化比喻：不同精度的尺子

> 想象你要测量物体长度：
>
> - **`char`** = 1 厘米尺（只能量 0–255 cm 或 -128–127 cm）  
> - **`short`** = 1 米尺（-32768–32767）  
> - **`int`** = 10 米卷尺（通常 -2e9–2e9）  
> - **`long long`** = 激光测距仪（-9e18–9e18）
>
> - **有符号（signed）**：尺子有正负刻度（可测方向）  
> - **无符号（unsigned）**：只有正刻度（距离不能为负）
>
> - **Java 对比**：Java 的尺子是**标准化的**（int 永远 32 位），C++ 的尺子**因工厂而异**（32 位 vs 64 位系统不同）。

> 💡 **关键认知**：**C++ 类型大小由实现定义（implementation-defined），非语言标准固定**。

---

### 📚 四、知识点分解

#### 1. 布尔类型 `bool`
- 取值：`true`（1）、`false`（0）
- 大小：通常 1 字节（但标准只保证 ≥1）
- 与 Java 相同

#### 2. 字符类型
| 类型 | 说明 |
|------|------|
| `char` | **平台相关**！可能是 `signed char` 或 `unsigned char`（由编译器决定） |
| `signed char` | 明确有符号，范围 -128 到 127 |
| `unsigned char` | 明确无符号，范围 0 到 255 |
> ✅ **最佳实践**：处理**数值**时用 `signed/unsigned char`，处理**文本**时用 `char`

#### 3–6. 整数类型（有符号 / 无符号）
| 类型 | 最小保证大小 | 典型大小（64 位 Linux） | Java 对应 |
|------|-------------|------------------------|----------|
| `short` | ≥16 位 | 16 位 | `short` |
| `int` | ≥16 位 | 32 位 | `int` |
| `long` | ≥32 位 | 64 位（Linux/macOS），32 位（Windows） | **无直接对应**（Java long = 64 位） |
| `long long` | ≥64 位 | 64 位 | `long` |

> ⚠️ **致命差异**：  
> **Java `long` = 64 位固定**  
> **C++ `long` = 32 位（Windows）或 64 位（Linux）** → **不可移植！**

#### 7. 有符号 vs 无符号
- **无符号类型**：溢出/下溢**定义良好**（模运算）
  ```cpp
  unsigned int x = 0;
  x--; // x = 4294967295（UINT_MAX）
  ```
- **有符号类型**：溢出 = **未定义行为（UB）**！
  ```cpp
  int y = INT_MAX;
  y++; // 未定义行为！可能 crash，可能静默错误
  ```

#### 8. 与 Java 的根本差异
| 特性 | C++ | Java |
|------|-----|------|
| **类型大小** | 平台相关 | 固定（int=32, long=64） |
| **char 符号性** | 实现定义 | 无符号（0–65535，UTF-16） |
| **无符号类型** | 有（unsigned int 等） | **无**（只有 signed） |
| **溢出行为** | unsigned: 定义良好<br>signed: 未定义 | 所有整数溢出定义良好（模运算） |

---

### 💻 五、动手为王：可运行示例

#### 示例 1：查看类型大小
```cpp
#include <iostream>
#include <climits>
#include <cstddef>

int main() {
    std::cout << "bool:        " << sizeof(bool) << " bytes\n";
    std::cout << "char:        " << sizeof(char) << " bytes\n";
    std::cout << "short:       " << sizeof(short) << " bytes\n";
    std::cout << "int:         " << sizeof(int) << " bytes\n";
    std::cout << "long:        " << sizeof(long) << " bytes\n";
    std::cout << "long long:   " << sizeof(long long) << " bytes\n";
    
    std::cout << "CHAR_MIN:    " << CHAR_MIN << "\n";
    std::cout << "CHAR_MAX:    " << CHAR_MAX << "\n";
    return 0;
}
```
> 📌 在不同平台运行，观察 `long` 大小差异！

---

#### 示例 2：无符号下溢（定义良好）
```cpp
#include <iostream>
#include <climits>

int main() {
    unsigned int x = 0;
    std::cout << "x = " << x << "\n";
    x--;
    std::cout << "x-- = " << x << " (should be " << UINT_MAX << ")\n";
    return 0;
}
```

---

#### 示例 3：有符号溢出（未定义行为！）
```cpp
#include <iostream>
#include <climits>

int main() {
    int y = INT_MAX;
    std::cout << "y = " << y << "\n";
    y++; // ⚠️ 未定义行为！
    std::cout << "y++ = " << y << "\n"; // 可能为负数，可能 crash
    return 0;
}
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **类型大小调查**  
   - 在你的机器上运行类型大小示例  
   - 记录 `int`、`long`、`long long` 的字节数

2. **无符号循环**  
   - 编写循环：`for (unsigned int i = 10; i >= 0; i--)`  
   - 问：会发生什么？如何修复？

#### 🔸 进阶题
3. **平台差异实验**  
   - 在 Windows（MSVC）和 Linux（g++）上编译同一代码  
   - 比较 `sizeof(long)` 是否相同

4. **char 符号性检测**  
   - 编写代码判断 `char` 是 signed 还是 unsigned：
     ```cpp
     char c = -1;
     bool is_signed = (c < 0); // 若 true，则 char 是 signed
     ```

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“我以为 long 是 64 位”**  
   ```cpp
   long timestamp = 1234567890123; // 13 位数字
   ```
   - Q: 在 Windows 上是否安全？  
   - A: ❌ 否！Windows `long` = 32 位，最大约 2e9 → **溢出**

6. **“无符号更安全？”**  
   - Q: 以下循环会终止吗？
     ```cpp
     for (unsigned i = 10; i >= 0; --i) { ... }
     ```
   - A: ❌ 否！`i` 永远 ≥0，下溢后变为大正数 → **无限循环**

---

### ⚠️ 七、注意事项与常见错误

| 问题 | 原因 | 建议 |
|------|------|------|
| **无限循环** | 无符号下溢 | 避免 `i >= 0` 条件；用 `i != 0` 或 `i > 0` |
| **平台移植错误** | 假设 `long` = 64 位 | 用 `int64_t`（见 1.2.6） |
| **char 符号混淆** | 用 `char` 存数值 | 明确使用 `signed char` / `unsigned char` |
| **有符号溢出** | 未检查边界 | 开启 `-ftrapv`（g++）或使用 sanitizers |

> 💡 **现代 C++ 建议**：  
> - 需要**固定大小**？ → 用 `<cstdint>` 中的 `int32_t`, `uint64_t` 等  
> - 需要**无符号**？ → 确保逻辑确实不需要负数  
> - 循环计数？ → 优先用 `size_t`（无符号，但注意边界）

---

### 🔁 八、螺旋复习

- **前序回顾**：KU 1.1 中我们编译了多文件项目，现在知道 `int` 大小可能因平台而异！
- **当日复习**：默写各类型最小保证大小
- **3 天后**：在 1.2.6（size_t）中学习固定大小类型
- **10 天后**：Phase 1 小测包含类型大小与溢出题

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 不像 Java 那样固定类型大小？”
   - “无符号类型在什么场景下真正有用？”（答案：位运算、哈希、数组索引）
2. **概念图**：画出 C++ 与 Java 整数类型对比表
3. **扮演教师**：向 Java 同事解释“为什么 `unsigned i >= 0` 永远为真”

---

### 🔍 十、复盘清单

✅ 我能说出各内置整数类型的最小保证大小  
✅ 我理解 `char` 的符号性是平台相关的  
✅ 我知道无符号溢出定义良好，有符号溢出是 UB  
✅ 我能识别 `unsigned` 循环陷阱  
✅ 我明白 C++ 与 Java 在类型大小上的根本差异

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 内置整数类型的核心知识**！

接下来你可以：
1. **继续学习 1.2.2 浮点类型：float, double, long double**
2. **请求生成「C++ vs Java 类型系统速查表」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续构建你的 C++ 类型系统心智模型！