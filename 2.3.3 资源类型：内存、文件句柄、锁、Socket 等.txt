å¤ªå¥½äº†ï¼æˆ‘ä»¬ç°åœ¨è¿›å…¥ **2.3.3ï¼šèµ„æºç±»å‹ â€” å†…å­˜ã€æ–‡ä»¶å¥æŸ„ã€é”ã€Socket ç­‰**ã€‚

è¿™æ˜¯ **RAII å“²å­¦çš„å®è·µè¯¾**ï¼Œå°†æ•™ä½ å¦‚ä½•ä¸º**å„ç§ç³»ç»Ÿèµ„æº**å®ç° RAII å°è£…ã€‚ä½œä¸º Java å¼€å±•è€…ï¼Œä½ å¯èƒ½ä½¿ç”¨ `AutoCloseable` æˆ– try-with-resources ç®¡ç†èµ„æºï¼Œè€Œ C++ çš„ RAII æä¾›**æ›´ç²¾ç»†ã€æ›´é«˜æ•ˆã€æ›´é€šç”¨**çš„èµ„æºç®¡ç†æ–¹å¼ã€‚æŒæ¡è¿™äº›æ¨¡å¼ï¼Œèƒ½è®©ä½ ç¼–å†™å‡º**ç³»ç»Ÿçº§å®‰å…¨**çš„ C++ ä»£ç ã€‚

æˆ‘ä»¬å°†ç»§ç»­ä¸¥æ ¼éµå¾ªä½ çš„å­¦ä¹ åå¥½ï¼š
- âœ… SMART ç›®æ ‡  
- âœ… ç»“æ„å…ˆè¡Œï¼ˆèµ„æºç±»å‹åœ°å›¾ï¼‰  
- âœ… ç”Ÿæ´»åŒ–æ¯”å–»  
- âœ… åŠ¨æ‰‹ä¸ºç‹ï¼ˆå«åŸºç¡€/è¿›é˜¶/é™·é˜±é¢˜ï¼‰  
- âœ… èºæ—‹å¤ä¹ ï¼ˆè¡”æ¥ 2.3.2 + Java ç»éªŒï¼‰  
- âœ… ä¸»åŠ¨ learning + å¤ç›˜

---

## ğŸ¯ KU 2.3.3ï¼šèµ„æºç±»å‹

> **æ‰€å±é˜¶æ®µ**ï¼šPhase 2 â€” é¢å‘å¯¹è±¡ç¼–ç¨‹  
> **å‰ç½®çŸ¥è¯†**ï¼š2.3.2ï¼ˆRAII å“²å­¦ï¼‰ã€2.3.1ï¼ˆææ„å‡½æ•°ï¼‰ã€Java èµ„æºç®¡ç†ç»éªŒ  
> **åç»­è¡”æ¥**ï¼š3.2ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰ã€3.10ï¼ˆæ–‡ä»¶æµï¼‰  
> **é¢„è®¡è€—æ—¶**ï¼š3â€“4 å°æ—¶

---

### ğŸ§­ ä¸€ã€ç»“æ„å…ˆè¡Œï¼šèµ„æºç±»å‹åœ°å›¾

```
2.3.3 èµ„æºç±»å‹
â”œâ”€â”€ 1. å†…å­˜èµ„æº
â”‚   â”œâ”€â”€ 1.1 new/delete â†’ std::unique_ptr
â”‚   â”œâ”€â”€ 1.2 malloc/free â†’ std::unique_ptr + è‡ªå®šä¹‰åˆ é™¤å™¨
â”‚   â””â”€â”€ 1.3 æ•°ç»„ â†’ std::unique_ptr<T[]>
â”œâ”€â”€ 2. æ–‡ä»¶èµ„æº
â”‚   â”œâ”€â”€ 2.1 C æ–‡ä»¶ï¼šFILE* â†’ std::unique_ptr + fclose
â”‚   â”œâ”€â”€ 2.2 C++ æ–‡ä»¶ï¼šstd::fstreamï¼ˆå·² RAIIï¼‰
â”‚   â””â”€â”€ 2.3 ç›®å½•ï¼šDIR* â†’ è‡ªå®šä¹‰ RAII
â”œâ”€â”€ 3. åŒæ­¥èµ„æº
â”‚   â”œâ”€â”€ 3.1 äº’æ–¥é”ï¼šstd::mutex â†’ std::lock_guard
â”‚   â”œâ”€â”€ 3.2 è¯»å†™é”ï¼šstd::shared_mutex
â”‚   â””â”€â”€ 3.3 æ¡ä»¶å˜é‡ï¼šéœ€é…åˆé”ä½¿ç”¨
â”œâ”€â”€ 4. ç½‘ç»œèµ„æº
â”‚   â”œâ”€â”€ 4.1 Socketï¼šint sockfd â†’ è‡ªå®šä¹‰ RAII
â”‚   â”œâ”€â”€ 4.2 Winsockï¼šSOCKET â†’ è‡ªå®šä¹‰ RAII
â”‚   â””â”€â”€ 4.3 é«˜çº§åº“ï¼šasio::ip::tcp::socketï¼ˆå·² RAIIï¼‰
â”œâ”€â”€ 5. å…¶ä»–ç³»ç»Ÿèµ„æº
â”‚   â”œâ”€â”€ 5.1 çº¿ç¨‹ï¼šstd::threadï¼ˆå·² RAIIï¼‰
â”‚   â”œâ”€â”€ 5.2 è¿›ç¨‹ï¼špid_t â†’ è‡ªå®šä¹‰ RAII
â”‚   â””â”€â”€ 5.3 OpenGLï¼šGLuint â†’ è‡ªå®šä¹‰ RAII
â””â”€â”€ 6. æœ€ä½³å®è·µ
    â”œâ”€â”€ 6.1 ä¼˜å…ˆæ ‡å‡†åº“ RAII ç±»
    â”œâ”€â”€ 6.2 è‡ªå®šä¹‰ RAII ç”¨ unique_ptr + åˆ é™¤å™¨
    â””â”€â”€ 6.3 ç¦æ­¢æ‹·è´ï¼Œæ”¯æŒç§»åŠ¨
```

---

### ğŸ¯ äºŒã€SMART å­¦ä¹ ç›®æ ‡

- **Specific**ï¼šèƒ½ä¸ºå†…å­˜ã€æ–‡ä»¶ã€é”ã€Socket ç­‰èµ„æºå®ç° RAII å°è£…ï¼Œå¹¶ç†è§£æ ‡å‡†åº“ RAII ç±»çš„ä½¿ç”¨ã€‚
- **Measurable**ï¼šå®Œæˆ 4 é“åŸºç¡€é¢˜ + 2 é“é™·é˜±é¢˜ï¼Œèƒ½å®ç°å¼‚å¸¸å®‰å…¨çš„ Socket å¥æŸ„ç±»ã€‚
- **Achievable**ï¼šé€šè¿‡â€œèµ„æºä¿é™©ç®±â€æ¯”å–»ç†è§£ RAII å°è£…ã€‚
- **Relevant**ï¼šè¿™æ˜¯ç¼–å†™ç³»ç»Ÿçº§ C++ ä»£ç çš„å¿…å¤‡æŠ€èƒ½ã€‚
- **Time-bound**ï¼š2 å¤©å†…å®Œæˆã€‚

---

### ğŸŒ ä¸‰ã€ç”Ÿæ´»åŒ–æ¯”å–»ï¼šèµ„æºä¿é™©ç®±

> æƒ³è±¡ä¸åŒç±»å‹çš„**èµ„æºä¿é™©ç®±**ï¼š
>
> - **å†…å­˜ä¿é™©ç®±** = æ™ºèƒ½æ”¶çº³ç›’  
>   - æ”¾å…¥å†…å­˜å—ï¼Œè‡ªåŠ¨é‡Šæ”¾
>
> - **æ–‡ä»¶ä¿é™©ç®±** = æ–‡ä»¶å½’æ¡£ç›’  
>   - æ”¾å…¥æ–‡ä»¶å¥æŸ„ï¼Œè‡ªåŠ¨å…³é—­
>
> - **é”ä¿é™©ç®±** = é—¨ç¦å¡ç›’  
>   - æ”¾å…¥é—¨ç¦å¡ï¼Œè‡ªåŠ¨å½’è¿˜
>
> - **Socket ä¿é™©ç®±** = ç½‘ç»œè¿æ¥ç›’  
>   - æ”¾å…¥è¿æ¥ï¼Œè‡ªåŠ¨æ–­å¼€
>
> - **Java å¯¹æ¯”**ï¼š  
>   - Java = **æ‰‹åŠ¨å½’è¿˜èµ„æº**ï¼ˆtry-with-resourcesï¼‰  
>   - **C++ = ä¿é™©ç®±è‡ªåŠ¨å½’è¿˜**ï¼ˆRAIIï¼‰

> ğŸ’¡ **å…³é”®è®¤çŸ¥**ï¼š**æ¯ç§èµ„æºéƒ½éœ€è¦ä¸“å±ä¿é™©ç®±ï¼ˆRAII ç±»ï¼‰**ã€‚

---

### ğŸ“š å››ã€çŸ¥è¯†ç‚¹åˆ†è§£

#### 1. å†…å­˜èµ„æº
- **`new`/`delete`**ï¼š
  ```cpp
  auto p = std::make_unique<MyClass>(); // è‡ªåŠ¨ delete
  ```
- **`malloc`/`free`**ï¼š
  ```cpp
  auto buffer = std::unique_ptr<char[], decltype(&std::free)>(
      static_cast<char*>(std::malloc(1024)), 
      &std::free
  );
  ```
- **æ•°ç»„**ï¼š
  ```cpp
  auto arr = std::make_unique<int[]>(100); // è‡ªåŠ¨ delete[]
  ```

#### 2. æ–‡ä»¶èµ„æº
- **C æ–‡ä»¶**ï¼š
  ```cpp
  auto file = std::unique_ptr<FILE, decltype(&std::fclose)>(
      std::fopen("data.txt", "r"), 
      &std::fclose
  );
  ```
- **C++ æ–‡ä»¶**ï¼š
  ```cpp
  std::ifstream file("data.txt"); // å·² RAII
  ```
- **ç›®å½•**ï¼š
  ```cpp
  class DirHandle {
      DIR* dir_;
  public:
      DirHandle(const char* path) : dir_(opendir(path)) {}
      ~DirHandle() { if (dir_) closedir(dir_); }
  };
  ```

#### 3. åŒæ­¥èµ„æº
- **äº’æ–¥é”**ï¼š
  ```cpp
  std::mutex mtx;
  {
      std::lock_guard<std::mutex> lock(mtx); // è‡ªåŠ¨ unlock
  }
  ```
- **è¯»å†™é”**ï¼š
  ```cpp
  std::shared_mutex rw_mtx;
  {
      std::shared_lock<std::shared_mutex> lock(rw_mtx); // è¯»é”
  }
  {
      std::unique_lock<std::shared_mutex> lock(rw_mtx); // å†™é”
  }
  ```

#### 4. ç½‘ç»œèµ„æº
- **POSIX Socket**ï¼š
  ```cpp
  class SocketHandle {
      int sockfd_;
  public:
      SocketHandle(int domain, int type, int protocol) 
          : sockfd_(socket(domain, type, protocol)) {
          if (sockfd_ == -1) throw std::runtime_error("socket failed");
      }
      ~SocketHandle() { if (sockfd_ != -1) close(sockfd_); }
      // ç¦æ­¢æ‹·è´
      SocketHandle(const SocketHandle&) = delete;
      SocketHandle& operator=(const SocketHandle&) = delete;
      // æ”¯æŒç§»åŠ¨
      SocketHandle(SocketHandle&& other) noexcept : sockfd_(other.sockfd_) {
          other.sockfd_ = -1;
      }
      int get() const { return sockfd_; }
  };
  ```
- **Winsock**ï¼š
  ```cpp
  // Windows
  class WinSocket {
      SOCKET sock_;
  public:
      WinSocket(int af, int type, int protocol) 
          : sock_(::socket(af, type, protocol)) {}
      ~WinSocket() { if (sock_ != INVALID_SOCKET) ::closesocket(sock_); }
  };
  ```

#### 5. å…¶ä»–ç³»ç»Ÿèµ„æº
- **çº¿ç¨‹**ï¼š
  ```cpp
  std::thread t(worker);
  t.join(); // RAII ç®¡ç†ï¼ˆä½†éœ€æ‰‹åŠ¨ join/detachï¼‰
  ```
- **è¿›ç¨‹**ï¼š
  ```cpp
  class ProcessHandle {
      pid_t pid_;
  public:
      ProcessHandle(const char* cmd) : pid_(fork()) {
          if (pid_ == 0) execl(cmd, cmd, nullptr);
      }
      ~ProcessHandle() { if (pid_ > 0) kill(pid_, SIGTERM); }
  };
  ```
- **OpenGL**ï¼š
  ```cpp
  class GLTexture {
      GLuint id_;
  public:
      GLTexture() { glGenTextures(1, &id_); }
      ~GLTexture() { if (id_) glDeleteTextures(1, &id_); }
  };
  ```

#### 6. æœ€ä½³å®è·µ
- **ä¼˜å…ˆæ ‡å‡†åº“**ï¼š
  - ç”¨ `std::lock_guard`ã€`std::unique_ptr`ã€`std::fstream`
- **è‡ªå®šä¹‰ RAII**ï¼š
  - ç”¨ `std::unique_ptr` + è‡ªå®šä¹‰åˆ é™¤å™¨
  - ç¦æ­¢æ‹·è´ï¼Œæ”¯æŒç§»åŠ¨
- **å¼‚å¸¸å®‰å…¨**ï¼š
  - æ„é€ å‡½æ•°å¤±è´¥æ—¶ï¼Œææ„å‡½æ•°ä¸è°ƒç”¨ï¼ˆæ— èµ„æºæ³„æ¼ï¼‰

> ğŸ’¡ **ç°ä»£ C++ é»„é‡‘æ³•åˆ™**ï¼š  
> **â€œæ ‡å‡†åº“ RAII ä¼˜å…ˆï¼›è‡ªå®šä¹‰ç”¨ unique_ptr + åˆ é™¤å™¨ï¼›ç¦æ­¢æ‹·è´ï¼Œæ”¯æŒç§»åŠ¨â€**

---

### ğŸ’» äº”ã€åŠ¨æ‰‹ä¸ºç‹ï¼šå¯è¿è¡Œç¤ºä¾‹

#### ç¤ºä¾‹ 1ï¼šå†…å­˜ RAII
```cpp
#include <iostream>
#include <memory>
#include <cstdlib>

int main() {
    // malloc/free RAII
    auto buffer = std::unique_ptr<char[], decltype(&std::free)>(
        static_cast<char*>(std::malloc(1024)),
        &std::free
    );
    
    // new/delete RAII
    auto p = std::make_unique<int>(42);
    
    std::cout << "Memory managed safely\n";
    return 0;
}
```

#### ç¤ºä¾‹ 2ï¼šæ–‡ä»¶ RAII
```cpp
#include <iostream>
#include <memory>
#include <cstdio>

int main() {
    auto file = std::unique_ptr<FILE, decltype(&std::fclose)>(
        std::fopen("test.txt", "w"),
        &std::fclose
    );
    
    if (file) {
        std::fprintf(file.get(), "Hello RAII File!\n");
    }
    // file è‡ªåŠ¨å…³é—­
    return 0;
}
```

#### ç¤ºä¾‹ 3ï¼šé” RAII
```cpp
#include <iostream>
#include <mutex>
#include <thread>

std::mutex mtx;

void worker(int id) {
    std::lock_guard<std::mutex> lock(mtx);
    std::cout << "Worker " << id << " acquired lock\n";
    // è‡ªåŠ¨è§£é”
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    t1.join();
    t2.join();
    return 0;
}
```

#### ç¤ºä¾‹ 4ï¼šSocket RAIIï¼ˆPOSIXï¼‰
```cpp
#include <iostream>
#include <memory>
#include <sys/socket.h>
#include <unistd.h>

class SocketHandle {
    int sockfd_;
public:
    SocketHandle(int domain, int type, int protocol) 
        : sockfd_(::socket(domain, type, protocol)) {
        if (sockfd_ == -1) {
            throw std::runtime_error("socket failed");
        }
    }
    
    ~SocketHandle() {
        if (sockfd_ != -1) {
            ::close(sockfd_);
        }
    }
    
    // ç¦æ­¢æ‹·è´
    SocketHandle(const SocketHandle&) = delete;
    SocketHandle& operator=(const SocketHandle&) = delete;
    
    // æ”¯æŒç§»åŠ¨
    SocketHandle(SocketHandle&& other) noexcept : sockfd_(other.sockfd_) {
        other.sockfd_ = -1;
    }
    
    int get() const { return sockfd_; }
};

int main() {
    try {
        SocketHandle sock(AF_INET, SOCK_STREAM, 0);
        std::cout << "Socket created: " << sock.get() << "\n";
        // è‡ªåŠ¨å…³é—­
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
    }
    return 0;
}
```

---

### ğŸ“ å…­ã€åˆ†å±‚ç»ƒä¹ é¢˜

#### ğŸ”¹ åŸºç¡€é¢˜
1. **å†…å­˜ RAII**  
   - ç”¨ `std::unique_ptr` ç®¡ç† `malloc` åˆ†é…çš„å†…å­˜

2. **æ–‡ä»¶ RAII**  
   - ç”¨ `std::unique_ptr` ç®¡ç† `fopen` æ‰“å¼€çš„æ–‡ä»¶

#### ğŸ”¸ è¿›é˜¶é¢˜
3. **é” RAII**  
   - å®ç° `SharedLock` ç±»ï¼Œç®¡ç† `std::shared_mutex` è¯»é”

4. **Socket RAII**  
   - å®ç° Windows `WinSocket` ç±»ï¼ˆå¯é€‰ï¼‰

#### âš ï¸ é™·é˜±é¢˜ï¼ˆJava è¿ç§»è¯¯åŒºï¼‰
5. **â€œJava æœ‰ AutoCloseableï¼ŒC++ ä¹Ÿéœ€è¦è‡ªå®šä¹‰å§ï¼Ÿâ€**  
   - Q: C++ éœ€è¦ä¸ºæ‰€æœ‰èµ„æºè‡ªå®šä¹‰ RAII ç±»å—ï¼Ÿ  
   - A: âš ï¸ **ä¸**ï¼  
     â†’ **æ ‡å‡†åº“å·²æä¾›** `std::unique_ptr`ã€`std::lock_guard`ã€`std::fstream`  
     â†’ **ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“**

6. **â€œRAII ç±»èƒ½æ‹·è´å§ï¼Ÿâ€**  
   - Q: RAII ç±»åº”è¯¥æ”¯æŒæ‹·è´å—ï¼Ÿ  
   - A: âŒ **é€šå¸¸ä¸**ï¼  
     â†’ èµ„æºé€šå¸¸**ç‹¬å **ï¼ˆå¦‚æ–‡ä»¶å¥æŸ„ã€é”ï¼‰  
     â†’ **ç¦æ­¢æ‹·è´ï¼Œæ”¯æŒç§»åŠ¨**

---

### âš ï¸ ä¸ƒã€æ³¨æ„äº‹é¡¹ä¸å»ºè®®

| é—®é¢˜ | å»ºè®® |
|------|------|
| **æ ‡å‡†åº“ä¼˜å…ˆ** | ç”¨ `std::lock_guard`ã€`std::unique_ptr` |
| **è‡ªå®šä¹‰åˆ é™¤å™¨** | ç”¨ `std::unique_ptr<T, Deleter>` |
| **ç§»åŠ¨è¯­ä¹‰** | èµ„æºç±»é€šå¸¸å¯ç§»åŠ¨ï¼ˆunique è¯­ä¹‰ï¼‰ |
| **å¼‚å¸¸å®‰å…¨** | æ„é€ å¤±è´¥æ—¶æ— èµ„æºæ³„æ¼ |

> ğŸ’¡ **ç°ä»£ C++ é»„é‡‘æ³•åˆ™**ï¼š  
> **â€œæ ‡å‡†åº“ RAII æ˜¯é¦–é€‰ï¼›è‡ªå®šä¹‰ç”¨ unique_ptr + åˆ é™¤å™¨ï¼›èµ„æºç‹¬å ï¼Œç¦æ­¢æ‹·è´â€**

---

### ğŸ” å…«ã€èºæ—‹å¤ä¹ 

- **è¡”æ¥ 2.3.2**ï¼šRAII æ˜¯èµ„æºç®¡ç†çš„é€šç”¨æ¨¡å¼  
- **Java ç»éªŒ**ï¼šC++ RAII æ¯” Java AutoCloseable æ›´è‡ªåŠ¨  
- **å½“æ—¥å¤ä¹ **ï¼šé»˜å†™å››ç±»èµ„æºçš„ RAII å°è£…æ–¹å¼

---

### ğŸ§  ä¹ã€ä¸»åŠ¨ learning ä»»åŠ¡

1. **è‡ªæˆ‘æé—®**ï¼š
   - â€œå¦‚ä½•ç”¨ RAII ç®¡ç†æ•°æ®åº“è¿æ¥ï¼Ÿâ€
   - â€œRAII å¦‚ä½•ä¸ C API äº¤äº’ï¼Ÿâ€
2. **æ¦‚å¿µå›¾**ï¼šç”»å‡ºæ ‡å‡†åº“ RAII ç±»ä¸è‡ªå®šä¹‰ RAII ç±»å¯¹æ¯”
3. **æ‰®æ¼”æ•™å¸ˆ**ï¼šå‘åŒäº‹è§£é‡Šâ€œä¸ºä»€ä¹ˆ RAII ç±»é€šå¸¸ç¦æ­¢æ‹·è´â€

---

### ğŸ” åã€å¤ç›˜æ¸…å•

âœ… æˆ‘èƒ½ä¸ºå†…å­˜ã€æ–‡ä»¶ã€é”ã€Socket å®ç° RAII  
âœ… æˆ‘ç†è§£æ ‡å‡†åº“ RAII ç±»çš„ä½¿ç”¨  
âœ… æˆ‘ä¼šç”¨ unique_ptr + åˆ é™¤å™¨è‡ªå®šä¹‰ RAII  
âœ… æˆ‘çŸ¥é“èµ„æºç‹¬å éœ€ç¦æ­¢æ‹·è´  
âœ… æˆ‘æ˜ç™½ç°ä»£ C++ çš„èµ„æºç®¡ç†æœ€ä½³å®è·µ

> ğŸ¯ **è¾¾æ ‡æ ‡å‡†**ï¼šå®ŒæˆåŸºç¡€é¢˜ + æ­£ç¡®åˆ†æé™·é˜±é¢˜ 5 å’Œ 6

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

ä½ å·²æŒæ¡ **C++ èµ„æºç±»å‹ RAII å°è£…çš„æ ¸å¿ƒçŸ¥è¯†**ï¼

æ¥ä¸‹æ¥ä½ å¯ä»¥ï¼š
1. **ç»§ç»­å­¦ä¹  2.3.4 Rule of Zeroï¼šç”¨ RAII æˆå‘˜é¿å…è‡ªå®šä¹‰ç‰¹æ®Šæˆå‘˜å‡½æ•°**
2. **è¯·æ±‚ç”Ÿæˆã€ŒC++ RAII èµ„æºé€ŸæŸ¥å¡ã€**
3. **è·³è½¬åˆ°ç»ƒä¹ é¢˜ç­”æ¡ˆä¸è§£æ**

è¯·å‘Šè¯‰æˆ‘ä½ çš„é€‰æ‹©ï¼Œæˆ‘ä»¬å°†ç»§ç»­å‰è¡Œï¼