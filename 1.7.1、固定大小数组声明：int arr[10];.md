太好了！我们现在进入 **1.7.1：固定大小数组声明 — int arr[10];**。

这是 C++ 中**最基础但也最危险**的数据结构之一。作为 Java 开发者，你习惯用 `new int[10]` 或 `ArrayList`，而 C++ 的固定大小数组是**栈分配、无边界检查、易退化为指针**的原始类型。理解其特性与陷阱，是避免缓冲区溢出、悬空指针等安全漏洞的第一步。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（数组地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 1.6 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.7.1：固定大小数组声明

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.6（结构体与内存布局）、Java 数组经验  
> **后续衔接**：1.7.2（数组退化为指针）、3.9（标准容器增强）  
> **预计耗时**：2–3 小时

---

### 🧭 一、结构先行：数组地图

```
1.7.1 固定大小数组
├── 1. 基本语法
│   ├── 1.1 声明：T arr[N];
│   ├── 1.2 栈分配（自动存储）
│   └── 1.3 编译期常量 N
├── 2. 内存布局
│   ├── 2.1 连续内存块
│   ├── 2.2 sizeof(arr) = N * sizeof(T)
│   └── 2.3 无额外元数据（如长度）
├── 3. 初始化
│   ├── 3.1 聚合初始化：int arr[3] = {1,2,3};
│   ├── 3.2 零初始化：int arr[10] = {};
│   └── 3.3 部分初始化：剩余元素 = 0
├── 4. 与 Java 的对比
│   ├── 4.1 Java: int[] arr = new int[10];
│   └── 4.2 C++: int arr[10]; （栈分配，无长度信息）
├── 5. 常见陷阱与最佳实践
    ├── 5.1 无边界检查（缓冲区溢出）
    ├── 5.2 不能拷贝（需 memcpy）
    └── 5.3 现代 C++ 替代方案（std::array）
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能正确定义和初始化固定大小数组，理解其内存布局，并避免常见陷阱。
- **Measurable**：完成 2 道基础题 + 2 道陷阱题，能解释为何 `sizeof(arr)` 在函数中失效。
- **Achievable**：通过“连续储物柜”比喻理解数组。
- **Relevant**：这是理解 C 风格字符串、指针算术、缓冲区安全的基础。
- **Time-bound**：1–2 天内完成。

---

### 🌍 三、生活化比喻：连续储物柜

> 想象一排**连续的储物柜**：
>
> - **数组 = 10 个连号柜子**（0–9）  
>   - 柜子大小 = `sizeof(T)`（如 int = 4 字节）
>   - **无管理员**：你可以打开任意柜子（包括 -1 或 10！）
>   - **无标签**：柜子上不写“共 10 个”（无长度信息）
>
> - **Java 对比**：  
>   - Java 数组像**带管理员的智能柜**：  
>     - 你只能开 0–9 号柜  
>     - 柜子上有标签“共 10 个”（`.length`）  
>   - **C++ 数组 = 裸柜子**，全靠自觉

> 💡 **关键认知**：**C++ 数组无运行时保护，越界 = 未定义行为（UB）**。

---

### 📚 四、知识点分解

#### 1. 基本语法
- **声明**：
  ```cpp
  int arr[10];        // 10 个 int 的数组
  double matrix[3][3]; // 3x3 二维数组
  ```
- **栈分配**：
  - 默认在栈上（自动存储）
  - 大数组可能导致栈溢出（1.4.7）
- **编译期常量**：
  - `N` 必须是编译期常量（C++11 前仅限字面量或 `const`）
  ```cpp
  constexpr int N = 10;
  int arr[N]; // OK (C++11)
  ```

#### 2. 内存布局
- **连续内存**：
  - `arr[0]`, `arr[1]`, ..., `arr[9]` 紧密排列
- **sizeof**：
  ```cpp
  int arr[10];
  std::cout << sizeof(arr); // 40 (10 * 4)
  ```
- **无长度信息**：
  - 数组本身**不存储长度**（需额外变量或约定）

#### 3. 初始化
- **聚合初始化**：
  ```cpp
  int arr[3] = {1, 2, 3}; // 全初始化
  ```
- **零初始化**：
  ```cpp
  int arr[10] = {}; // 全 0
  ```
- **部分初始化**：
  ```cpp
  int arr[5] = {1, 2}; // arr = {1,2,0,0,0}
  ```

#### 4. 与 Java 的对比
| 特性 | C++ 数组 | Java 数组 |
|------|---------|----------|
| **分配位置** | 栈 or 全局 | 仅堆 |
| **边界检查** | ❌ 无 | ✅ 有（`ArrayIndexOutOfBoundsException`）|
| **长度信息** | ❌ 无（需 `sizeof/sizeof(T)`） | ✅ 有（`.length`）|
| **拷贝** | 需 `memcpy` | 直接赋值（引用拷贝）|
| **多维数组** | 连续内存（`int[3][3]`） | 指针数组（`int[][]`）|

#### 5. 常见陷阱
- **缓冲区溢出**：
  ```cpp
  int arr[3] = {1,2,3};
  arr[3] = 4; // UB！可能 crash，可能静默错误
  ```
- **函数中 sizeof 失效**：
  ```cpp
  void f(int arr[10]) {
      std::cout << sizeof(arr); // 8（指针大小），非 40！
  }
  ```
- **不能直接拷贝**：
  ```cpp
  int a[5] = {1,2,3,4,5};
  int b[5] = a; // 错误！不能拷贝数组
  // 需 memcpy(b, a, sizeof(a));
  ```

> 💡 **现代 C++ 替代方案**：
> - **`std::array<T, N>`**（C++11）：
>   - 栈分配，连续内存
>   - 有 `.size()`，支持拷贝，边界检查（`at()`）
>   - **零开销抽象**（性能同 C 数组）

---

### 💻 五、动手为王：可运行示例

#### 示例 1：基本数组声明与初始化
```cpp
#include <iostream>

int main() {
    // 基本声明
    int arr[5];
    
    // 聚合初始化
    int init[3] = {10, 20, 30};
    
    // 零初始化
    double zeros[4] = {};
    
    // 部分初始化
    char partial[5] = {'a', 'b'}; // {'a','b','\0','\0','\0'}
    
    std::cout << "init: ";
    for (int i = 0; i < 3; ++i) std::cout << init[i] << " ";
    std::cout << "\nzeros: " << zeros[0] << "\n";
    std::cout << "partial: " << partial << "\n"; // C 风格字符串
    
    return 0;
}
```

#### 示例 2：sizeof 陷阱（函数中）
```cpp
#include <iostream>

void in_function(int arr[10]) {
    std::cout << "In function: sizeof(arr) = " << sizeof(arr) << "\n"; // 8 (pointer)
}

int main() {
    int arr[10];
    std::cout << "In main: sizeof(arr) = " << sizeof(arr) << "\n"; // 40
    in_function(arr); // 数组退化为指针！
    return 0;
}
```

#### 示例 3：现代替代（std::array）
```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    
    std::cout << "Size: " << arr.size() << "\n"; // 5
    std::cout << "arr[0] = " << arr[0] << "\n";
    
    // 安全访问（边界检查）
    // std::cout << arr.at(10) << "\n"; // throw std::out_of_range
    
    // 直接拷贝
    auto arr2 = arr; // OK
    
    return 0;
}
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **数组声明**  
   - 声明 `double coords[3]`，初始化为 `{1.0, 2.0, 3.0}`

2. **sizeof 验证**  
   - 在 main 中打印 `sizeof(coords)`

#### 🔸 进阶题
3. **函数陷阱**  
   - 编写函数 `print_size(int arr[5])`，观察 `sizeof(arr)`

4. **现代替代**  
   - 用 `std::array<double, 3>` 重写 coords 示例

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“数组能直接赋值吧？”**  
   - Q: `int a[5] = {1,2,3,4,5}; int b[5] = a;` 合法吗？  
   - A: ❌ **非法**！  
     → C++ 不允许数组直接拷贝  
     → Java 中 `int[] b = a;` 是引用拷贝（非内容拷贝）

6. **“arr.length 存在吧？”**  
   - Q: C++ 数组有 `.length` 属性吗？  
   - A: ❌ **没有**！  
     → 需用 `sizeof(arr)/sizeof(arr[0])`（仅在定义处有效）

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **缓冲区溢出** | 用 `std::array::at()` 或手动检查 |
| **函数传递** | 用模板或 `std::array` 保留大小信息 |
| **大数组** | 避免栈分配（用 `std::vector`） |
| **现代替代** | 优先 `std::array`（C++11+） |
| **调试** | 用 AddressSanitizer 检测越界 |

> 💡 **现代 C++ 黄金法则**：  
> **“新代码用 `std::array`，遗留代码小心边界”**

---

### 🔁 八、螺旋复习

- **衔接 1.4.1**：数组默认栈分配
- **衔接 1.6.7**：数组是连续内存，无 padding
- **Java 经验**：C++ 数组无边界检查，需手动管理
- **当日复习**：默写数组三大陷阱（越界、sizeof、拷贝）

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 不给数组加长度信息？”
   - “`std::array` 如何实现零开销？”
2. **概念图**：画出 C++ 数组 vs Java 数组的内存布局对比
3. **扮演教师**：向同事解释“为什么函数中 sizeof(arr) 不是数组大小”

---

### 🔍 十、复盘清单

✅ 我能正确定义和初始化固定大小数组  
✅ 我理解数组的内存布局与限制  
✅ 我知道函数中数组退化为指针  
✅ 我会用 `std::array` 安全替代  
✅ 我明白 C++ 与 Java 数组的根本差异

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 固定大小数组的核心知识**！

接下来你可以：
1. **继续学习 1.7.2 数组退化为指针：函数参数中的数组实为指针**
2. **请求生成「C++ 数组安全使用速查卡」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！