太好了！我们现在进入 **1.3.3：空指针 — NULL vs nullptr（C++11 引入）**。

这是 C++11 带来的**看似微小却意义重大**的改进。作为 Java 开发者，你熟悉 `null`，但在 C++98/03 中，空指针是用宏 `NULL`（通常定义为 `0`）表示的，这导致**类型系统漏洞和重载歧义**。`nullptr` 的引入修复了这些问题，使空指针成为**类型安全的一等公民**。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（空指针演化地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 1.3.1–1.3.2 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.3.3：空指针（NULL vs nullptr）

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.3.1（指针基础）、1.3.2（声明语法）  
> **后续衔接**：1.9（const 正确性）、3.6（nullptr 专题）  
> **预计耗时**：2–3 小时

---

### 🧭 一、结构先行：空指针演化地图

```
1.3.3 空指针
├── 1. C 时代的 NULL
│   ├── 1.1 #define NULL 0
│   ├── 1.2 类型问题：int vs 指针
│   └── 1.3 重载歧义
├── 2. C++11 的 nullptr
│   ├── 2.1 std::nullptr_t 类型
│   ├── 2.2 类型安全：只能转为指针/bool
│   └── 2.3 重载决议优势
├── 3. 与 Java null 的对比
├── 4. 最佳实践
│   ├── 4.1 永远使用 nullptr
│   └── 4.2 遗留代码处理
└── 5. 常见陷阱与迁移指南
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能解释 `NULL` 与 `nullptr` 的差异，理解 `nullptr` 的类型安全优势，并在代码中正确使用。
- **Measurable**：完成 3 道基础题 + 2 道陷阱题，能修复重载歧义问题。
- **Achievable**：通过“专用钥匙”比喻理解类型安全。
- **Relevant**：这是编写现代、安全 C++ 代码的基础。
- **Time-bound**：1–2 天内完成。

---

### 🌍 三、生活化比喻：万能钥匙 vs 专用钥匙

> 想象你要打开一扇**指针之门**：
>
> - **`NULL`（=0） = 万能钥匙**  
>   - 它能开**指针之门**，也能开**整数之门**、**浮点之门**...  
>   - **问题**：当你只想开指针之门时，系统不知道你的真实意图！
>
> - **`nullptr` = 专用指针钥匙**  
>   - 它**只能开指针之门**，不能用于其他类型  
>   - **结果**：系统明确知道“这是空指针”，不会混淆
>
> - **Java `null` = 专用引用钥匙**  
>   - 只能用于引用类型，不能用于基本类型（如 `int`）

> 💡 **关键认知**：**`nullptr` 是类型安全的空指针字面量**。

---

### 📚 四、知识点分解

#### 1. C 时代的 `NULL`
- **定义**（通常）：
  ```cpp
  #define NULL 0          // C++
  // 或
  #define NULL ((void*)0) // C（但 C++ 不允许 void* 隐式转其他指针）
  ```
- **问题**：
  - `NULL` 本质是 **整数字面量 `0`**
  - 可隐式转换为 **任何算术类型**（int, float...）和 **指针类型**
- **重载歧义示例**：
  ```cpp
  void f(int);
  void f(char*);
  f(NULL); // 调用 f(int)！因为 0 是 int
  ```

#### 2. C++11 的 `nullptr`
- **类型**：`std::nullptr_t`（定义在 `<cstddef>`）
- **特性**：
  - 可隐式转换为 **任何指针类型**（包括成员指针）
  - 可转换为 **bool**（值为 `false`）
  - **不能**转换为 **算术类型**（int, float...）
- **重载优势**：
  ```cpp
  void f(int);
  void f(char*);
  f(nullptr); // 明确调用 f(char*)
  ```

#### 3. 与 Java `null` 的对比
| 特性 | C++ `nullptr` | Java `null` |
|------|--------------|------------|
| **类型** | `std::nullptr_t` | null type（无名） |
| **可赋值给** | 任何指针/bool | 任何引用类型 |
| **不可赋值给** | 算术类型 | 基本类型（int, boolean...） |
| **重载安全** | ✅ 是 | ✅ 是 |
| **历史包袱** | 有（NULL） | 无 |

#### 4. 最佳实践
- **新代码**：**永远使用 `nullptr`**
- **遗留代码**：逐步替换 `NULL` → `nullptr`
- **头文件**：无需额外 include（`nullptr` 是关键字）

#### 5. 常见陷阱
- **`NULL` 在模板中**：
  ```cpp
  template<typename T>
  void reset(T* p) { *p = NULL; } // 错误！若 T=int，则 *p = 0（合法但非意图）
  ```
  ✅ 修复：`*p = {};`（值初始化）或避免此模式
- **`nullptr` 与 `0` 比较**：
  ```cpp
  int* p = nullptr;
  if (p == 0) { ... } // 合法但不推荐
  if (p == nullptr) { ... } // 推荐
  ```

---

### 💻 五、动手为王：可运行示例

#### 示例 1：重载歧义修复
```cpp
#include <iostream>

void f(int x) {
    std::cout << "f(int): " << x << "\n";
}

void f(char* s) {
    std::cout << "f(char*): " << (s ? s : "null") << "\n";
}

int main() {
    // 使用 NULL（危险）
    f(NULL);      // 输出: f(int): 0

    // 使用 nullptr（安全）
    f(nullptr);   // 输出: f(char*): null
    return 0;
}
```

#### 示例 2：类型安全验证
```cpp
#include <iostream>

int main() {
    int* p = nullptr; // OK
    bool b = nullptr; // OK: b = false

    // int x = nullptr; // 编译错误！不能转为 int

    if (!p) {
        std::cout << "p is null\n";
    }
    if (b == false) {
        std::cout << "b is false\n";
    }
    return 0;
}
```

#### 示例 3：模板中的 nullptr
```cpp
#include <iostream>
#include <memory>

template<typename T>
void safe_delete(T*& p) {
    delete p;
    p = nullptr; // 安全：nullptr 可赋给任何指针
}

int main() {
    int* p = new int(42);
    safe_delete(p);
    std::cout << "p = " << p << "\n"; // 0（或 nullptr 表示）
    return 0;
}
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **安全赋值**  
   - 声明 `double* pd;`，将其设为空指针（使用 `nullptr`）

2. **重载测试**  
   - 编写两个重载函数 `void g(int)` 和 `void g(float*)`  
   - 调用 `g(nullptr)`，验证调用的是指针版本

#### 🔸 进阶题
3. **模板安全**  
   - 编写模板函数 `make_null<T>()` 返回 `T*` 类型的 `nullptr`

4. **bool 转换**  
   - 验证 `bool b = nullptr;` 的值是否为 `false`

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“NULL 和 nullptr 一样吧？”**  
   - Q: 以下代码在 C++98 和 C++11 中行为是否相同？
     ```cpp
     void h(long);
     void h(char*);
     h(NULL);      // C++98
     h(nullptr);   // C++11
     ```
   - A: ❌ **不同**！  
     - C++98：`NULL=0` → 调用 `h(long)`  
     - C++11：`nullptr` → 调用 `h(char*)`

6. **“我能用 0 代替 nullptr 吗？”**  
   - Q: `int* p = 0;` 是否合法？  
   - A: ✅ **合法但不推荐**！  
     → 语义不清晰，可能引起重载歧义

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **遗留代码** | 用 clang-tidy 或 IDE 批量替换 `NULL` → `nullptr` |
| **可读性** | `if (p == nullptr)` 比 `if (!p)` 更明确（但后者也常用） |
| **函数参数** | 接受指针的函数，用 `nullptr` 作为默认空值 |
| **智能指针** | `std::unique_ptr<T> p;` 默认为空，无需显式 `= nullptr` |
| **调试** | `nullptr` 在调试器中显示为 `0x0` 或 `nullptr` |

> 💡 **现代 C++ 建议**：
> - **永远用 `nullptr`**，忘记 `NULL` 和 `0` 作为空指针
> - **函数重载**：`nullptr` 使指针重载更可靠
> - **模板代码**：`nullptr` 提供类型安全的空指针

---

### 🔁 八、螺旋复习

- **衔接 1.3.1**：空指针是解引用前必须检查的条件
- **衔接 1.2.5**：`nullptr` 在布尔上下文为 `false`
- **Java 经验**：`nullptr` ≈ Java `null`，但用于指针而非引用
- **当日复习**：默写 `nullptr` 的三大优势

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 不直接用 `null` 关键字？”
   - “`std::nullptr_t` 有什么成员函数？”（答：几乎没有，仅用于类型）
2. **概念图**：画出 `NULL` vs `nullptr` 的类型转换图
3. **扮演教师**：向同事解释“为什么 `f(NULL)` 可能调用错误的重载”

---

### 🔍 十、复盘清单

✅ 我能说出 `NULL` 与 `nullptr` 的本质差异  
✅ 我理解 `nullptr` 的类型安全优势  
✅ 我会用 `nullptr` 修复重载歧义  
✅ 我知道现代 C++ 应永远使用 `nullptr`  
✅ 我明白 `nullptr` 与 Java `null` 的异同

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5

---

## 🚀 下一步建议

你已掌握 **C++ 空指针的现代用法**！

接下来你可以：
1. **继续学习 1.3.4 指针算术：+、-、[] 操作的内存偏移含义**
2. **请求生成「nullptr 迁移检查清单」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续深入指针世界！