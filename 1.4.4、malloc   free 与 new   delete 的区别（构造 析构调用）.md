太好了！我们现在进入 **1.4.4：malloc / free 与 new / delete 的区别（构造/析构调用）**。

这是 C++ 内存管理中一个**承前启后的关键知识点**。`malloc`/`free` 是 C 语言的内存管理函数，而 `new`/`delete` 是 C++ 的运算符。虽然它们都操作堆内存，但 **`new`/`delete` 是类型安全的，会调用构造/析构函数，而 `malloc`/`free` 只是原始字节分配器**。理解这一区别，是避免“C 风格”错误、拥抱 C++ 对象模型的基础。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（内存管理对比地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 1.4.1–1.4.3 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.4.4：malloc / free 与 new / delete 的区别

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.4.1–1.4.3（栈与堆内存）、C 语言基础（可选）  
> **后续衔接**：2.3（RAII）、3.2（智能指针）  
> **预计耗时**：2–3 小时

---

### 🧭 一、结构先行：内存管理对比地图

```
1.4.4 malloc/free vs new/delete
├── 1. 来源与类型
│   ├── 1.1 malloc/free：C 标准库函数
│   ├── 1.2 new/delete：C++ 运算符
│   └── 1.3 类型安全性
├── 2. 功能差异
│   ├── 2.1 malloc：仅分配原始字节
│   ├── 2.2 new：分配内存 + 调用构造函数
│   ├── 2.3 free：仅释放原始字节
│   └── 2.4 delete：调用析构函数 + 释放内存
├── 3. 语法与使用
│   ├── 3.1 malloc 需要 sizeof 和强制类型转换
│   ├── 3.2 new 自动计算大小，返回正确类型
│   └── 3.3 数组版本：calloc/realloc vs new[]
├── 4. 错误配对陷阱
│   ├── 4.1 malloc + delete → UB
│   ├── 4.2 new + free → UB
│   └── 4.3 为什么 UB？
├── 5. 与 Java 的对比
└── 6. 现代 C++ 建议
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能解释 `malloc`/`free` 与 `new`/`delete` 的核心差异，理解构造/析构调用的重要性，并避免混合使用。
- **Measurable**：完成 2 道基础题 + 2 道陷阱题，能诊断混合使用导致的 UB。
- **Achievable**：通过“毛坯房 vs 精装房”比喻理解初始化差异。
- **Relevant**：这是编写类型安全、资源安全 C++ 代码的基础。
- **Time-bound**：1–2 天内完成。

---

### 🌍 三、生活化比喻：毛坯房 vs 精装房

> 想象你要租一套房子：
>
> - **`malloc`/`free` = 租毛坯房**  
>   - 你只拿到**空房间**（原始字节）  
>   - **必须自己装修**（手动初始化）  
>   - 退租时**直接走人**（不清理装修）
>
> - **`new`/`delete` = 租精装房**  
>   - 房东（C++ 运行时）**自动装修好**（调用构造函数）  
>   - 退租时**自动清理**（调用析构函数）
>
> - **混合使用 = 灾难**：  
>   - 用 `malloc` 租毛坯房，却让房东按精装房退租（`delete`） → **房东试图清理不存在的装修**  
>   - 用 `new` 租精装房，却自己直接走人（`free`） → **装修垃圾堆积（析构未调用）**

> 💡 **关键认知**：**`new`/`delete` 是对象感知的，`malloc`/`free` 是原始字节操作**。

---

### 📚 四、知识点分解

#### 1. 来源与类型
| 特性 | `malloc`/`free` | `new`/`delete` |
|------|----------------|---------------|
| **来源** | C 标准库（`<cstdlib>`） | C++ 关键字 |
| **类型** | 函数 | 运算符 |
| **类型安全** | ❌ 返回 `void*`，需强制转换 | ✅ 返回 `T*`，类型安全 |

#### 2. 功能差异
- **`malloc(size_t size)`**：
  - 分配 `size` 字节的**未初始化**内存
  - 返回 `void*`（需 cast to `T*`）
  - **不调用构造函数**
- **`new T`**：
  - 分配 `sizeof(T)` 字节内存
  - **调用 `T` 的构造函数**
  - 返回 `T*`
- **`free(void* ptr)`**：
  - 释放内存
  - **不调用析构函数**
- **`delete T* ptr`**：
  - **调用 `T` 的析构函数**
  - 释放内存

#### 3. 语法与使用
```cpp
// malloc/free（C 风格）
int* p1 = static_cast<int*>(malloc(10 * sizeof(int)));
// 必须手动初始化
free(p1);

// new/delete（C++ 风格）
int* p2 = new int[10]; // 自动初始化（基本类型为 0？不！见注）
delete[] p2;

// 对象类型
MyClass* obj1 = static_cast<MyClass*>(malloc(sizeof(MyClass)));
// obj1 未构造！不能直接使用
free(obj1);

MyClass* obj2 = new MyClass(); // 构造函数被调用
delete obj2; // 析构函数被调用
```
> ⚠️ **注意**：`new int` 不初始化（值随机），`new int()` 值初始化为 0

#### 4. 错误配对陷阱（UB！）
| 错误 | 后果 |
|------|------|
| `malloc` + `delete` | **尝试调用析构函数**，但对象未构造 → UB |
| `new` + `free` | **析构函数未调用**，资源泄漏 → UB |
| `malloc` + `delete[]` | 同上，且数组元数据不匹配 → UB |

#### 5. 与 Java 的对比
| 特性 | C++ `new` | Java `new` |
|------|----------|-----------|
| **内存分配** | 堆 | 堆 |
| **初始化** | 调用构造函数 | 调用构造函数 |
| **释放** | 手动 `delete` | 自动 GC |
| **原始分配** | `malloc`（不推荐） | 无（`ByteBuffer.allocateDirect` 接近） |

#### 6. 现代 C++ 建议
- **永远不要在 C++ 中使用 `malloc`/`free`**（除非调用 C 库）
- **优先栈对象** → **智能指针** → **裸 `new`/`delete`**
- **C 库交互**：用 RAII 封装 `malloc`/`free`（如自定义 deleter 的 `unique_ptr`）

> 💡 **黄金法则**：**C++ 代码中，只用 `new`/`delete`（或更好：智能指针）**

---

### 💻 五、动手为王：可运行示例

#### 示例 1：功能差异（Tracker 类）
```cpp
#include <iostream>
#include <cstdlib>

class Tracker {
public:
    Tracker() { std::cout << "Constructed\n"; }
    ~Tracker() { std::cout << "Destructed\n"; }
};

int main() {
    // new/delete：构造+析构
    std::cout << "=== new/delete ===\n";
    Tracker* p1 = new Tracker();
    delete p1;

    // malloc/free：无构造/析构
    std::cout << "\n=== malloc/free ===\n";
    Tracker* p2 = static_cast<Tracker*>(malloc(sizeof(Tracker)));
    // p2 未构造！不能安全使用
    free(p2); // 无析构调用

    return 0;
}
```
> ✅ 输出：
> ```
> === new/delete ===
> Constructed
> Destructed
> 
> === malloc/free ===
> ```

#### 示例 2：混合使用（UB！）
```cpp
#include <iostream>
#include <cstdlib>

int main() {
    // 危险：malloc + delete
    Tracker* p1 = static_cast<Tracker*>(malloc(sizeof(Tracker)));
    delete p1; // UB！试图析构未构造对象

    // 危险：new + free
    Tracker* p2 = new Tracker();
    std::free(p2); // UB！析构函数未调用

    return 0;
}
```

#### 示例 3：C 库交互（安全封装）
```cpp
#include <iostream>
#include <memory>
#include <cstdlib>

// 安全封装 malloc/free
auto malloc_deleter = [](void* p) { std::free(p); };
using MallocPtr = std::unique_ptr<void, decltype(malloc_deleter)>;

int main() {
    MallocPtr p{std::malloc(100), malloc_deleter};
    // 自动调用 free
    return 0;
}
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **安全分配**  
   - 用 `new` 创建 `Tracker` 对象，验证构造/析构  
   - 用 `malloc` 分配相同大小，验证无构造/析构

2. **语法转换**  
   - 将 `int* p = (int*)malloc(10 * sizeof(int));` 转为 C++ 风格

#### 🔸 进阶题
3. **C 库封装**  
   - 用 `std::unique_ptr` 封装 `malloc`/`free`，管理 `char` 数组

4. **初始化差异**  
   - 比较 `new int`、`new int()`、`malloc(sizeof(int))` 的初始值

#### ⚠️ 陷阱题（迁移误区）
5. **“malloc 和 new 一样吧？”**  
   - Q: 以下代码安全吗？
     ```cpp
     MyClass* p = (MyClass*)malloc(sizeof(MyClass));
     p->method(); // 调用成员函数
     free(p);
     ```
   - A: ❌ **不安全**！  
     → 对象未构造，`this` 指针无效 → UB

6. **“free 能释放 new 的内存吗？”**  
   - Q: `int* p = new int(42); free(p);` 合法吗？  
   - A: ❌ **非法**！  
     → 虽然基本类型无析构，但**仍是 UB**（内存管理器不匹配）

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **混合使用** | 绝对禁止 `malloc`+`delete` 或 `new`+`free` |
| **C 库交互** | 用智能指针自定义 deleter 封装 |
| **调试** | 用 AddressSanitizer 检测 UB |
| **现代替代** | 优先 `std::vector`、`std::unique_ptr` |
| **教学目的** | 仅在解释 C/C++ 差异时提及 `malloc` |

> 💡 **现代 C++ 建议**：
> - **C++ 代码中**：只用 `new`/`delete`（或智能指针）
> - **调用 C 库时**：用 RAII 封装 `malloc`/`free`
> - **永远不要**：在 C++ 中直接使用 `malloc`/`free`

---

### 🔁 八、螺旋复习

- **衔接 1.4.2**：`new`/`delete` 调用构造/析构，`malloc`/`free` 不调用
- **衔接 2.3**：RAII 依赖确定性析构（`delete` 提供）
- **Java 经验**：C++ 手动管理 vs Java GC，但都调用构造函数
- **当日复习**：默写混合使用的 UB 后果

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 不废弃 `malloc`？”
   - “`calloc` 和 `new T()` 有什么区别？”
2. **概念图**：画出 `malloc` vs `new` 的内存操作流程
3. **扮演教师**：向同事解释“为什么不能混用 `malloc` 和 `delete`”

---

### 🔍 十、复盘清单

✅ 我能说出 `malloc`/`free` 与 `new`/`delete` 的核心差异  
✅ 我理解构造/析构调用的重要性  
✅ 我知道混合使用的 UB 后果  
✅ 我会用智能指针安全封装 C 库  
✅ 我明白现代 C++ 应避免 `malloc`/`free`

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 内存管理的核心差异**！

接下来你可以：
1. **继续学习 1.4.5 内存泄漏定义与常见场景（忘记 delete、异常路径）**
2. **请求生成「内存管理安全速查卡」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！