非常好！我们现在进入 **Phase 3：C++11 特性（80 小时）**，这是现代 C++ 的**分水岭阶段**。C++11 被广泛认为是“第二个 C++ 语言”——它引入了移动语义、智能指针、自动类型推导等革命性特性，极大提升了代码安全性、性能与表达力。

我们将继续采用“结构先行”原则，构建一份**三级（必要时四级）知识地图**，聚焦 **“从传统 C++ 向现代 C++ 范式迁移”** 的核心能力。

---

## 🗺️ Phase 3：C++11 特性（80 小时）  
> 主题：拥抱现代 C++，告别裸指针与手动资源管理，掌握值语义、移动语义与泛型编程新范式

---

### **3.1 auto 与 decltype**
3.1.1 `auto` 类型推导：编译期自动推断变量类型  
3.1.2 `auto` 在复杂类型（如迭代器、lambda）中的简化作用  
3.1.3 `auto&`、`const auto&`、`auto&&`（万能引用初步）  
3.1.4 `decltype` 表达式类型查询：`decltype(x)`、`decltype((x))` 差异  
3.1.5 `decltype(auto)`：C++14 扩展（此处仅概念提及）  
3.1.6 与 Java `var` 对比：Java 10+ 引入，但 C++ `auto` 更早且更强大（支持引用/const）  
3.1.7 使用原则：提升可读性，但不滥用（避免类型模糊）

---

### **3.2 智能指针**
3.2.1 裸指针的问题回顾：泄漏、悬空、所有权模糊  
3.2.2 `std::unique_ptr<T>`：独占所有权，不可拷贝，可移动  
3.2.3 `std::shared_ptr<T>`：共享所有权，引用计数，线程安全计数（但非对象线程安全）  
3.2.4 `std::weak_ptr<T>`：打破 `shared_ptr` 循环引用  
3.2.5 智能指针创建：`make_unique`（C++14）、`make_shared`（高效内存布局）  
3.2.6 自定义删除器（Deleter）：适配非 `delete` 资源（如 `fclose`）  
3.2.7 与 Java GC 对比：智能指针是**确定性析构**，GC 是**非确定性回收**  
3.2.8 使用准则：优先值语义，其次 `unique_ptr`，最后 `shared_ptr`

---

### **3.3 移动语义与右值引用**
3.3.1 左值（lvalue） vs 右值（rvalue）：具名 vs 临时对象  
3.3.2 右值引用语法：`T&&`  
3.3.3 移动构造函数：`T(T&& other)`  
3.3.4 移动赋值运算符：`T& operator=(T&& other)`  
3.3.5 `std::move`：强制转换为右值引用（不移动，只“允许移动”）  
3.3.6 移动语义带来的性能提升：避免深拷贝（如 vector 扩容）  
3.3.7 “五法则”（Rule of Five）完整版：析构 + 拷贝/移动 构造/赋值  
3.3.8 移动语义与异常安全：`noexcept` 移动函数更高效（如 vector 重分配）  
3.3.9 与 Java 对比：Java 无移动语义，对象始终在堆上，赋值是引用拷贝

---

### **3.4 Lambda 表达式**
3.4.1 基本语法：`[capture](params) -> ret { body }`  
3.4.2 捕获列表：`[]`（无捕获）、`[=]`（值捕获）、`[&]`（引用捕获）、`[x, &y]`（混合）  
3.4.3 mutable：允许修改值捕获的副本  
3.4.4 返回类型推导：省略 `-> ret` 时自动推导  
3.4.5 Lambda 本质：编译器生成的匿名仿函数类（含 operator()）  
3.4.6 与 Java Lambda 对比：Java 捕获变量必须是 effectively final  
3.4.7 应用场景：STL 算法谓词、回调函数、线程任务  
3.4.8 泛型 Lambda（C++14）：`auto` 参数（此处仅预告）

---

### **3.5 范围 for 循环（Range-based for）**
3.5.1 语法：`for (auto& elem : container)`  
3.5.2 支持的容器：数组、std::vector、std::list 等提供 begin()/end() 的类型  
3.5.3 引用 vs 值：`auto&`（修改元素）、`const auto&`（只读）、`auto`（拷贝）  
3.5.4 与传统 for 对比：更安全（无越界）、更简洁  
3.5.5 与 Java for-each 对比：语义高度相似

---

### **3.6 nullptr**
3.6.1 问题背景：`NULL` 是宏（通常为 0），类型不安全  
3.6.2 `nullptr` 类型：`std::nullptr_t`，可隐式转换为任意指针类型  
3.6.3 重载决议优势：`f(int)` vs `f(char*)`，传 `nullptr` 调用后者  
3.6.4 与 Java `null` 对比：Java `null` 是引用类型字面量，C++ `nullptr` 是指针字面量

---

### **3.7 初始化列表与统一初始化**
3.7.1 统一初始化语法：`T obj{args};`（大括号初始化）  
3.7.2 初始化列表构造函数：`std::vector<int> v{1,2,3};`  
3.7.3 避免“最令人烦恼的解析”（Most Vexing Parse）：`T obj();` 是函数声明  
3.7.4 聚合类型初始化：`struct Point { int x, y; }; Point p{1,2};`  
3.7.5 与 Java 初始化对比：Java 无统一初始化，数组/集合初始化语法各异

---

### **3.8 constexpr**
3.8.1 `constexpr` 变量：编译期常量（需字面量初始化）  
3.8.2 `constexpr` 函数：C++11 限制（仅单 return 语句）  
3.8.3 编译期计算 vs 运行期计算：性能与模板元编程基础  
3.8.4 与 `const` 区别：`const` 是运行期常量，`constexpr` 是编译期常量  
3.8.5 与 Java `final` 对比：Java 无编译期函数计算能力（直到 Java 21 的 `const` 提案）

---

### **3.9 标准容器增强**
3.9.1 `std::array<T, N>`：栈上固定大小数组，替代 C 风格数组  
3.9.2 `std::unordered_map` / `unordered_set`：哈希表容器  
3.9.3 `emplace` 系列：`emplace_back`, `emplace` —— 直接构造元素，避免临时对象  
3.9.4 容器的移动语义支持：`vector` 移动 O(1)  
3.9.5 与 Java 集合对比：Java 无栈容器，无 `emplace` 语义

---

### **3.10 线程支持库 (std::thread)**
3.10.1 `std::thread` 创建与 join/detach  
3.10.2 线程函数传递：值拷贝、引用（需 `std::ref`）  
3.10.3 互斥锁：`std::mutex`、`std::lock_guard`（RAII 锁）  
3.10.4 条件变量：`std::condition_variable`  
3.10.5 异步任务：`std::async`、`std::future`、`std::promise`  
3.10.6 与 Java 并发对比：Java Thread/ExecutorService vs C++ std::thread/future  
3.10.7 内存模型与原子操作（`std::atomic`）初步概念

---

✅ **Phase 3 知识地图完成**：共 10 个 KU，下探至 3–4 级，覆盖 C++11 核心现代特性。

> 💡 **关键范式转变**：  
> - **从“管理指针” → “管理对象”**（值语义优先）  
> - **从“手动释放” → “RAII + 智能指针”**  
> - **从“拷贝一切” → “移动临时对象”**  
> - **从“运行期计算” → “编译期计算”**（constexpr）

---

## 🔜 下一步建议

你现在拥有 **Phase 1–3 的完整知识骨架**（共 34 个 KU）。接下来你可以：

1. **继续细化 Phase 4：C++14 特性**（C++11 的实用增强）  
2. **请求生成「C++11 与 Java 的现代特性对比表」**（如 Lambda、线程、泛型）  
3. **选择 Phase 3 中某个关键 KU（如 3.3 移动语义 或 3.2 智能指针）进行深度教学设计**（含代码、陷阱题、RAII 实践）

请告诉我你的下一步方向，我们将继续构建这份系统化、可执行的 480 小时转型计划。