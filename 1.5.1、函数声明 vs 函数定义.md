太好了！我们现在进入 **1.5.1：函数声明 vs 函数定义**。

这是 C++ 多文件编程的**基石概念**，也是与 Java 模块化方式的根本差异之一。Java 中方法定义即可见，而 C++ 要求**先声明后使用**（除非定义在前），这直接影响头文件设计、编译依赖和项目结构。掌握这一区别，是编写可维护 C++ 项目的起点。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（函数地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 1.1 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.5.1：函数声明 vs 函数定义

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.1（编译与构建模型）、Java 方法经验  
> **后续衔接**：1.5.2（参数传递）、1.10（头文件机制）  
> **预计耗时**：2–3 小时

---

### 🧭 一、结构先行：函数声明/定义地图

```
1.5.1 函数声明 vs 定义
├── 1. 函数声明（Function Declaration）
│   ├── 1.1 语法：返回类型 + 函数名 + 参数列表 + ;
│   ├── 1.2 作用：告诉编译器“函数存在”
│   └── 1.3 别名：函数原型（Function Prototype）
├── 2. 函数定义（Function Definition）
│   ├── 2.1 语法：声明 + 函数体 { ... }
│   ├── 2.2 作用：提供函数实现
│   └── 2.3 必须有且仅有一个（ODR）
├── 3. 声明 vs 定义对比
│   ├── 3.1 语法差异
│   ├── 3.2 编译器视角
│   └── 3.3 链接器视角
├── 4. 与 Java 的对比
└── 5. 常见错误与最佳实践
    ├── 5.1 未声明就使用
    ├── 5.2 多次定义
    └── 5.3 头文件放置原则
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能区分函数声明与定义，理解其在编译/链接中的作用，并正确组织多文件项目。
- **Measurable**：完成 2 道基础题 + 2 道陷阱题，能修复“未声明”编译错误。
- **Achievable**：通过“菜单 vs 菜品”比喻理解声明/定义。
- **Relevant**：这是 C++ 多文件项目的基础。
- **Time-bound**：1–2 天内完成。

---

### 🌍 三、生活化比喻：餐厅菜单 vs 菜品制作

> 想象一家餐厅：
>
> - **函数声明 = 菜单**  
>   - 告诉你：“本店有宫保鸡丁（参数：辣度），返回一盘菜”  
>   - **不包含做法**，只描述接口
>
> - **函数定义 = 厨房做法**  
>   - 包含完整烹饪步骤（函数体）  
>   - **只能有一份标准做法**（ODR）
>
> - **顾客点菜（调用函数）**：  
>   - 只需看菜单（声明），无需知道做法  
>   - 厨房（链接器） later 按菜单提供菜品
>
> - **Java 对比**：  
>   - Java 像**开放式厨房**：你点菜时能看到做法（定义即可见）  
>   - **C++ 像传统餐厅**：你只能看菜单（声明），做法在后厨（定义）

> 💡 **关键认知**：**C++ 编译器只需声明即可调用，定义由链接器 later 提供**。

---

### 📚 四、知识点分解

#### 1. 函数声明（Function Declaration）
- **语法**：
  ```cpp
  int add(int a, int b); // 分号结尾，无函数体
  ```
- **作用**：
  - 告诉编译器：函数存在，参数/返回类型是什么
  - 允许在定义前调用函数
- **别名**：函数原型（Function Prototype）

#### 2. 函数定义（Function Definition）
- **语法**：
  ```cpp
  int add(int a, int b) { // 无分号，有函数体
      return a + b;
  }
  ```
- **作用**：
  - 提供函数的具体实现
  - **必须有且仅有一个**（ODR：One Definition Rule）

#### 3. 声明 vs 定义对比
| 特性 | 声明 | 定义 |
|------|------|------|
| **语法** | 以 `;` 结尾 | 以 `{}` 结尾 |
| **函数体** | 无 | 有 |
| **数量** | 可多次声明 | 必须唯一定义 |
| **编译器需求** | 调用前必须可见 | 链接时必须存在 |
| **放置位置** | 头文件（.h） | 源文件（.cpp） |

#### 4. 与 Java 的对比
| 特性 | C++ | Java |
|------|-----|------|
| **方法可见性** | 需显式声明（头文件） | 定义即可见（同文件或 import） |
| **编译依赖** | 仅需声明 | 需要完整类定义 |
| **多文件组织** | .h（声明） + .cpp（定义） | .java（声明+定义一体） |
| **默认行为** | 未声明不能调用 | 同类方法可任意顺序 |

#### 5. 常见错误
- **未声明就使用**：
  ```cpp
  int main() {
      return add(2, 3); // 错误！'add' 未声明
  }
  int add(int a, int b) { return a + b; } // 定义在后
  ```
  ✅ 修复：先声明，或定义在前
- **多次定义**：
  ```cpp
  // math.h
  int add(int a, int b) { return a + b; } // 错误！定义在头文件
  ```
  → 若多个 .cpp #include "math.h" → 链接错误（multiple definition）
  ✅ 修复：定义移至 .cpp，头文件只放声明
- **头文件放置原则**：
  - **声明** → .h
  - **定义** → .cpp（inline/模板除外）

> 💡 **现代 C++ 建议**：
> - **头文件**：只放声明（函数、类、变量 extern）
> - **源文件**：放定义
> - **inline 函数**：可放头文件（但需 inline 关键字）

---

### 💻 五、动手为王：可运行示例

#### 示例 1：正确分离（声明 in .h, 定义 in .cpp）
**文件：`math.h`**
```cpp
#ifndef MATH_H
#define MATH_H
int add(int a, int b); // 声明
#endif
```

**文件：`math.cpp`**
```cpp
#include "math.h"
int add(int a, int b) { // 定义
    return a + b;
}
```

**文件：`main.cpp`**
```cpp
#include "math.h" // 包含声明
int main() {
    return add(2, 3); // 编译通过（看到声明）
}
```

#### 示例 2：常见错误（未声明）
```cpp
// wrong.cpp
int main() {
    return add(2, 3); // 编译错误：'add' was not declared
}

int add(int a, int b) {
    return a + b;
}
```
> ❌ 输出：  
> `error: 'add' was not declared in this scope`

#### 示例 3：多次定义（头文件放定义）
**文件：`bad.h`**
```cpp
int add(int a, int b) { return a + b; } // 错误：定义在头文件
```

**文件：`a.cpp`**
```cpp
#include "bad.h"
```

**文件：`b.cpp`**
```cpp
#include "bad.h"
```

**编译**：
```bash
g++ a.cpp b.cpp -o app
```
> ❌ 输出：  
> `multiple definition of 'add'`

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **声明/定义识别**  
   - 判断以下哪行是声明，哪行是定义：
     ```cpp
     void print(int x);
     void print(int x) { std::cout << x << "\n"; }
     ```

2. **多文件项目**  
   - 创建 `utils.h`/`utils.cpp`/`main.cpp`，实现 `square` 函数

#### 🔸 进阶题
3. **修复未声明错误**  
   - 修复以下代码：
     ```cpp
     int main() {
         greet("Alice");
     }
     void greet(const std::string& name) {
         std::cout << "Hello, " << name << "!\n";
     }
     ```

4. **头文件原则**  
   - 解释为什么 `inline` 函数可放头文件

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“Java 中方法顺序无所谓，C++ 也一样吧？”**  
   - Q: 以下代码在 C++ 中合法吗？
     ```cpp
     int main() {
         foo();
     }
     void foo() {
         std::cout << "Hello\n";
     }
     ```
   - A: ❌ **非法**！  
     → C++ 需先声明 `void foo();`，或定义在 `main` 前  
     → Java 允许任意顺序

6. **“头文件放定义更方便”**  
   - Q: 能否在头文件放函数定义？  
   - A: ⚠️ **仅限 inline/模板**！  
     → 普通函数定义在头文件 → 多次包含 → 链接错误

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **未声明错误** | 在使用前包含头文件或前置声明 |
| **多次定义** | 头文件只放声明，定义放 .cpp |
| **inline 函数** | 小函数用 `inline` 放头文件 |
| **模板** | 定义必须放头文件（Phase 2） |
| **现代实践** | 用 CMake 管理多文件项目 |

> 💡 **黄金法则**：  
> **“.h 是合同（声明），.cpp 是履约（定义）”**

---

### 🔁 八、螺旋复习

- **衔接 1.1.1**：.h 放声明，.cpp 放定义
- **衔接 1.1.3**：编译器只需声明即可编译
- **Java 经验**：C++ 需显式声明，Java 定义即可见
- **当日复习**：默写声明/定义语法差异

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 不像 Java 那样定义即可见？”
   - “前置声明（forward declaration）有什么用？”
2. **概念图**：画出函数声明/定义在编译/链接中的流程
3. **扮演教师**：向同事解释“为什么头文件不能放普通函数定义”

---

### 🔍 十、复盘清单

✅ 我能区分函数声明与定义  
✅ 我理解声明在编译时的作用  
✅ 我知道定义必须唯一（ODR）  
✅ 我会正确组织 .h/.cpp 文件  
✅ 我明白 C++ 与 Java 在函数可见性上的差异

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 函数声明与定义的核心知识**！

接下来你可以：
1. **继续学习 1.5.2 参数传递方式：值传递、指针传递、引用传递**
2. **请求生成「函数声明/定义速查卡」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！