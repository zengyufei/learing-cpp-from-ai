太好了！我们现在进入 **1.1.7：构建工具简介 — g++ 命令行、Makefile 基础、CMake 入门概念**。

这是 **Phase 1 中承上启下的实用技能课**。你已经理解了 C++ 的构建原理（1.1.1–1.1.6），现在我们将学习**如何高效、可重复地执行这个过程**。虽然现代 C++ 项目多用 CMake，但理解 **g++ 命令行 → Makefile → CMake** 的演进逻辑，能让你在调试构建问题时游刃有余。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（工具演进地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含可运行示例）  
- ✅ 螺旋复习（整合 1.1 全模块）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.1.7：构建工具简介

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.1.1–1.1.6（C++ 构建全流程 + Java 对比）  
> **教学定位**：**概念性掌握 + 基础实操**，非深度构建系统专家  
> **预计耗时**：3–4 小时

---

### 🧭 一、结构先行：构建工具演进地图

```
1.1.7 构建工具
├── 1. 手动编译：g++ 命令行
│   ├── 1.1 基本语法：g++ [选项] file.cpp -o output
│   ├── 1.2 常用选项：-std, -I, -L, -l, -c, -g, -O2
│   └── 1.3 适用场景：单文件、快速测试
├── 2. 自动化构建：Makefile
│   ├── 2.1 什么是 Make？依赖驱动构建
│   ├── 2.2 Makefile 基本语法：target: dependencies
│   ├── 2.3 规则与变量
│   └── 2.4 适用场景：中小型项目
└── 3. 跨平台构建：CMake（入门）
    ├── 3.1 什么是 CMake？生成构建系统
    ├── 3.2 CMakeLists.txt 基本结构
    ├── 3.3 常用命令：add_executable, target_link_libraries
    └── 3.4 适用场景：中大型、跨平台项目
```

> 💡 **演进逻辑**：  
> **手动 → 自动化 → 跨平台抽象**

---

### 🎯 二、SMART 学习目标

- **Specific**：能使用 g++ 编译多文件项目；能编写简单 Makefile；能创建基础 CMake 项目。
- **Measurable**：完成 3 个动手实验（g++ → Make → CMake）。
- **Achievable**：通过“食谱”比喻理解构建自动化。
- **Relevant**：这是参与任何 C++ 项目的必备技能。
- **Time-bound**：2 天内完成。

---

### 🌍 三、生活化比喻：烹饪食谱

> - **g++ 命令行 = 手工烹饪**  
>   每次都要记住：“先切菜（-c），再炒（链接），加盐（-O2）…”  
>   → 小菜可应付，大餐易出错。
>
> - **Makefile = 标准食谱**  
>   写好步骤：“若食材更新，则重做这道菜”  
>   → 自动化，避免重复劳动。
>
> - **CMake = 跨厨房食谱生成器**  
>   写一份通用食谱，CMake 自动生成“中式厨房（Makefile）”或“西式厨房（Visual Studio）”专用版本  
>   → 一次编写，处处构建。

> 💡 **关键认知**：**CMake 不是构建工具，而是“构建系统生成器”**。

---

### 📚 四、知识点分解

#### 1. g++ 命令行（手动构建）
- **基本编译**：
  ```bash
  g++ main.cpp math.cpp -o app          # 一步编译+链接
  ```
- **分步编译**（推荐理解流程）：
  ```bash
  g++ -c main.cpp        # → main.o
  g++ -c math.cpp        # → math.o
  g++ main.o math.o -o app  # 链接
  ```
- **常用选项**：
  | 选项 | 作用 |
  |------|------|
  | `-std=c++17` | 指定 C++ 标准 |
  | `-I/path` | 添加头文件搜索路径 |
  | `-L/path` | 添加库搜索路径 |
  | `-lmath` | 链接 libmath.so 或 libmath.a |
  | `-g` | 生成调试信息 |
  | `-O2` | 优化级别 2 |
  | `-Wall -Wextra` | 启用更多警告 |

#### 2. Makefile（自动化构建）
- **核心思想**：**目标（target）依赖于文件，若依赖更新，则重建目标**
- **基本语法**：
  ```makefile
  app: main.o math.o
      g++ main.o math.o -o app

  main.o: main.cpp math.h
      g++ -c main.cpp

  math.o: math.cpp math.h
      g++ -c math.cpp

  clean:
      rm -f *.o app
  ```
- **执行**：
  ```bash
  make     # 构建 app
  make clean  # 清理
  ```
- **优点**：只重编译修改的文件，节省时间

#### 3. CMake（跨平台构建）
- **工作流程**：
  1. 编写 `CMakeLists.txt`
  2. 运行 `cmake .` → 生成 Makefile（或 VS 工程等）
  3. 运行 `make` → 构建项目
- **基础 CMakeLists.txt**：
  ```cmake
  cmake_minimum_required(VERSION 3.10)
  project(MyApp)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)

  add_executable(app main.cpp math.cpp)
  ```
- **构建命令**：
  ```bash
  mkdir build && cd build
  cmake ..    # 生成构建系统
  make        # 构建
  ```

---

### 💻 五、动手为王：三阶段实验

> 📌 环境：Linux/macOS 终端（Windows 用户可用 WSL 或 Git Bash）

#### 实验 1：g++ 手动构建

**文件**：`math.h`, `math.cpp`, `main.cpp`（同前）

**命令**：
```bash
# 一步构建
g++ -std=c++17 main.cpp math.cpp -o app_gpp

# 分步构建
g++ -c main.cpp
g++ -c math.cpp
g++ main.o math.o -o app_gpp2

./app_gpp
```

---

#### 实验 2：Makefile 自动化

**创建 `Makefile`**：
```makefile
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Wextra

app: main.o math.o
	$(CXX) $^ -o $@

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	rm -f *.o app
```

**执行**：
```bash
make        # 构建
make clean  # 清理
make        # 再次构建（若未改代码，会跳过）
```

> 💡 `$^` = 所有依赖，`$@` = 目标，`$<` = 第一个依赖

---

#### 实验 3：CMake 跨平台构建

**创建 `CMakeLists.txt`**：
```cmake
cmake_minimum_required(VERSION 3.10)
project(ConfigApp)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(app main.cpp math.cpp)
```

**构建**：
```bash
mkdir build
cd build
cmake ..
make
./app
```

> ✅ 优势：同一份 `CMakeLists.txt` 可在 Windows（生成 VS 工程）、Linux（Makefile）、macOS（Xcode）使用

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **g++ 实验**  
   - 用 g++ 编译一个包含 3 个 .cpp 文件的项目  
   - 使用 `-I` 指定自定义头文件目录

2. **Makefile 实验**  
   - 编写 Makefile，支持 `make` 和 `make clean`  
   - 修改一个 .cpp，验证 `make` 只重编译该文件

#### 🔸 进阶题
3. **CMake 实验**  
   - 创建 CMake 项目，添加 `-Wall -Wextra` 编译选项  
   - 使用 `target_include_directories` 添加头文件路径

#### ⚠️ 陷阱题
4. **“我以为 CMake 是编译器”**  
   - Q: 运行 `cmake ..` 后，程序是否已编译？  
   - A: ❌ 否！CMake 只生成构建文件，需再运行 `make`（或 ninja 等）

5. **Makefile 缩进错误**  
   - Q: Makefile 中命令行必须用 **Tab** 缩进，用空格会怎样？  
   - A: `Makefile:2: *** missing separator. Stop.`

---

### ⚠️ 七、注意事项与建议

| 工具 | 常见错误 | 建议 |
|------|--------|------|
| **g++** | 忘记链接 .cpp 文件 | 始终检查是否包含所有源文件 |
| **Makefile** | 空格代替 Tab | 用 `cat -A Makefile` 查看不可见字符 |
| **CMake** | 在源码目录运行 cmake | 始终用 **out-of-source build**（`mkdir build`） |
| **通用** | 忽略编译警告 | 开启 `-Wall -Wextra`，警告即错误 |

> 💡 **现代实践建议**：
> - **学习阶段**：掌握 g++ 和简单 Makefile
> - **项目开发**：直接使用 CMake（行业标准）
> - **调试构建问题**：学会看生成的 Makefile 或 compile_commands.json

---

### 🔁 八、螺旋复习

- **整合 1.1 全模块**：
  - g++ 命令体现 1.1.4（链接）
  - Makefile 自动化 1.1.1–1.1.5 流程
  - CMake 抽象了平台差异（呼应 1.1.6）
- **当日复习**：默写 CMake 基础结构
- **后续衔接**：Phase 3 将深入 CMake 现代用法

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 CMake 要用两步构建（cmake + make）？”
   - “Makefile 能跨平台吗？”
2. **概念图**：画出 g++ → Make → CMake 的抽象层次
3. **扮演教师**：向同事解释“为什么 CMake 不是构建工具”

---

### 🔍 十、复盘清单

✅ 我能用 g++ 编译多文件项目  
✅ 我能编写简单 Makefile  
✅ 我能创建基础 CMake 项目  
✅ 我理解三者的适用场景  
✅ 我知道 CMake 是“构建系统生成器”

> 🎯 **达标标准**：完成三个动手实验

---

## 🏁 KU 1.1 完整闭环

你已完整掌握 **KU 1.1：C++ 编译与构建模型** 的全部 7 个子知识点！  
从原理（1.1.1–1.1.5）到对比（1.1.6）再到工具（1.1.7），形成了**完整认知闭环**。

> 🎉 **你现在能**：
> - 设计多文件 C++ 项目结构
> - 诊断并修复编译/链接错误
> - 使用 g++/Make/CMake 构建项目
> - 向 Java 同事解释 C++ 构建差异

---

## 🚀 下一步建议

你可以选择：

1. **继续学习 1.2 基本类型与字面量**
2. **请求生成「KU 1.1 综合小测」（10 道题，含构建命令填空）**
3. **导出「C++ 构建工具速查卡」（g++/Make/CMake 常用命令）**

请告诉我你的选择，我们将继续前行！