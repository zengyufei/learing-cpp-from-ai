## **break 与 continue 控制循环流程**  

---

### 【第 1 步：问题引入——如何让循环“半路退出”或“跳过一步”？】（09:00–09:10）

> 同学，你已经会用 `for` 和 `while` 重复做事。  
>  
> 但现实需求更精细：  
> - **猜数字时，一旦猜中，立刻停止**——不需要再猜；  
> - **打印 1–20 的奇数时，遇到偶数直接跳过**——不执行后续逻辑。  
>  
> 如果只用 `if`，你会写很多嵌套，代码臃肿。  
>  
> 今天，C++ 给你两个“秘密武器”：  
> - **`break`**：立即跳出循环；  
> - **`continue`**：跳过本次，进入下一次。  
>  
> 它们不是魔法，而是**精准控制循环流程的手术刀**。  
>  
> 准备好升级你的循环控制力了吗？

---

### 【第 2 步：break 讲解——循环的“紧急出口”】（09:10–09:25）

> **`break` 的作用**：  
> - 在 `for` 或 `while` 中，**立即终止整个循环**；  
> - 程序跳到循环后的第一条语句继续执行。

> **典型场景：提前终止搜索**  
> 比如判断质数：
> ```cpp
> bool is_prime = true;
> for (int i = 2; i < n; i++) {
>     if (n % i == 0) {
>         is_prime = false;
>         break; // 找到因子，无需继续检查
>     }
> }
> ```
> **生活化比喻**：  
> > “`break` 像消防通道——商场着火（找到因子），立刻撤离，不管购物车里还有什么。”

> **注意**：  
> - `break` 只影响**当前最内层循环**；  
> - 不能在循环外使用（编译报错）。

---

### 【第 3 步：continue 讲解——循环的“筛子”】（09:25–09:40）

> **`continue` 的作用**：  
> - 跳过循环体中 `continue` 之后的代码；  
> - **直接进入下一次迭代**。

> **在 `for` 中的行为**：  
> 1. 执行 `continue`；  
> 2. **执行更新表达式**（如 `i++`）；  
> 3. 检查条件，决定是否继续。

> **典型场景：数据过滤**  
> 打印 1–20 的奇数：
> ```cpp
> for (int i = 1; i <= 20; i++) {
>     if (i % 2 == 0) {
>         continue; // 跳过偶数
>     }
>     std::cout << i << " "; // 只处理奇数
> }
> ```
> **生活化比喻**：  
> > “`continue` 像筛沙子——小石子（偶数）直接漏掉，只留下大颗粒（奇数）。”

> **关键区别**：  
> - `break` → **退出整个循环**；  
> - `continue` → **跳过本次，继续下一次**。

---

### 【第 4 步：嵌套循环中的行为——只影响最内层】（09:40–09:50）

> 看这段嵌套循环：
> ```cpp
> for (int i = 0; i < 3; i++) {
>     for (int j = 0; j < 3; j++) {
>         if (j == 1) {
>             break; // 只跳出内层循环！
>         }
>         std::cout << i << "," << j << "\n";
>     }
> }
> ```
> **输出**：
> ```
> 0,0
> 1,0
> 2,0
> ```
>  
> **为什么**？  
> - `break` 只终止 `j` 循环；  
> - `i` 循环继续执行。  
>  
> **重要原则**：  
> > “`break` 和 `continue` 永远只对**最近的循环**生效。”

---

### 【第 5 步：动手实践——你来用“手术刀”优化代码】（09:50–10:20）

> 现在轮到你了：

> **【基础任务】单循环控制（20 分钟）**  
> 1. **质数判断**：输入 `n`，用 `break` 优化因子搜索；  
> 2. **奇数打印**：用 `continue` 跳过 1–20 中的偶数；  
> 3. **输入终止**：用 `while` 读整数，输入 `-1` 时 `break` 退出。

> **【进阶任务】嵌套与游戏（25 分钟）**  
> 4. **乘法表优化**：打印九九表，但当 `i*j > 30` 时 `break` 内层；  
> 5. **猜数字增强**：猜中时 `break` 退出；输入 `0` 表示放弃，也 `break`。

> **【陷阱任务】while 中的 continue 陷阱（5 分钟）**  
> 分析并修复：
> ```cpp
> Int i = 0;
> While (i < 5) {
>     if (i == 2) continue;
>     std:: cout << i << "\n";
>     i++; // 若 continue 在 i++ 前？
> }
> ```
> → 如果 `i++` 在 `continue` 后，当 `i=2` 时，`i` 永不更新 → **无限循环**！  
> **修复**：确保更新在 `continue` 之前，或改用 `for`。

---

### 【第 6 步：即时反馈——为什么 while 中的 continue 更危险？】（10:20–10:25）

> 有同学问：“为什么 `for` 中 `continue` 安全，`while` 中危险？”  
>  
> 因为：  
> - `for` 的**更新表达式**（`i++`）**总在每次迭代末尾自动执行**，即使有 `continue`；  
> - `while` **没有自动更新**——你必须自己写 `i++`，且要确保它在 `continue` **之前**执行。  
>  
> **黄金法则**：  
> > “在 `while` 中用 `continue`，务必检查循环变量是否会被更新！”  
>  
> 否则，你会得到一个**安静的无限循环**——最危险的 bug。

---

### 【第 7 步：总结 + 衔接下一阶段】（10:25–10:30）

> 今天我们给循环装上了“智能控制器”：  
>  
> ✅ 用 `break` 实现提前退出；  
> ✅ 用 `continue` 实现条件跳过；  
> ✅ 理解了它们在嵌套循环中的行为。  
>  
> 但光有工具还不够——你需要**综合应用所有控制流知识**。  
>  
> 下一阶段（10:30–12:00），我们将进行 **第 2 天首次综合小测**：  
> - 快速回顾控制流核心概念；  
> - 编程实战：实现带重试的菜单系统；  
> - 错误修复：找出并修正 5 处典型控制流错误。  
>  
> 而你今天学的 `break`/`continue`，将成为小测中优化逻辑的关键。  
>  
> 准备好接受第一次控制流实战检验了吗？我们继续。

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“问题 → break → continue → 嵌套 → 实践 → 陷阱”为逻辑链；  
> - ✅ 生活化比喻：“消防通道”“筛沙子”贯穿控制流讲解；  
> - ✅ 动手为王：三层任务（基础/进阶/陷阱），含质数、猜数字等经典场景；  
> - ✅ 防错前置：强调 `while` 中 `continue` 的更新陷阱、嵌套作用域；  
> - ✅ 衔接清晰：为10:30–12:00的当日小测提供 `break`/`continue` 应用能力支撑。
