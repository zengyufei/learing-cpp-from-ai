## **控制流综合编码训练——条件与循环的典型应用与错误调试**  

---

### 【第 1 步：目标说明——今天不做新知识，只练“真功夫”】（07:30–07:40）

> 同学，过去 6 个半小时，你已经学完了 C++ 控制流的“字母表”：  
> - `if` 做选择，`while` 做未知重复，`for` 做已知计数。  
>  
> 但光会念字母，不等于会写文章。  
>  
> 今天接下来的 90 分钟，**我们不学任何新语法**，只做一件事：  
>  
> ✅ **用已学知识解决经典问题**；  
> ✅ **亲手制造并修复典型错误**；  
> ✅ **把“控制流”从语法变成直觉**。  
>  
> 因为——**编程不是记住规则，而是驯服逻辑**。  
>  
> 今天练扎实了，后面学函数、数组时，你才有底气说：“我能搞定它。”

---

### 【第 2 步：典型问题示范——从闰年到斐波那契】（07:40–08:00）

> **问题 1：闰年判断（多条件组合）**  
> 规则：能被 4 整除但不能被 100 整除，**或**能被 400 整除。  
> ```cpp
> if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
>     std::cout << "Leap year\n";
> } else {
>     std::cout << "Common year\n";
> }
> ```
> **关键点**：括号确保逻辑正确，测试边界：2000（闰）、1900（平）、2024（闰）。

> **问题 2：阶乘计算（for 计数）**  
> ```cpp
> int fact = 1;
> for (int i = 1; i <= n; i++) {
>     fact *= i;
> }
> // 注意：0! = 1，循环从1开始自然满足
> ```

> **问题 3：斐波那契数列（while 未知项）**  
> ```cpp
> int a = 0, b = 1;
> int count = 0;
> while (count < n) {
>     if (count == 0) std::cout << a << " ";
>     else if (count == 1) std::cout << b << " ";
>     else {
>         int next = a + b;
>         std::cout << next << " ";
>         a = b; b = next;
>     }
>     count++;
> }
> ```
> **生活化比喻**：  
> > “`for` 像按食谱做蛋糕——步骤固定；  
> > `while` 像煮面——你不知道要煮多久，直到面条变软。”

---

### 【第 3 步：错误陷阱剖析——三类经典控制流 bug】（08:00–08:15）

> **陷阱 1：无限循环（更新缺失）**  
> ```cpp
> for (int i = 10; i >= 0; i--) {
>     std::cout << i << "\n";
>     i++; // ← 错！抵消了 i--，i 永远 >=0
> }
> ```
> **修复**：删除 `i++`，或确保更新方向正确。

> **陷阱 2：悬空 else（花括号缺失）**  
> ```cpp
> if (x > 0)
>     if (y > 0)
>         std::cout << "Q1\n";
>     else
>         std::cout << "Q4\n"; // 实际属于内层 if！
> ```
> **修复**：外层 `if` 加花括号：
> ```cpp
> if (x > 0) {
>     if (y > 0) ...
> }
> else {
>     std::cout << "Q4\n";
> }
> ```

> **陷阱 3：边界遗漏（闰年规则不全）**  
> ```cpp
> if (year % 4 == 0) { ... } // ← 忘了 100/400 规则
> ```
> **修复**：补全复合条件。

---

### 【第 4 步：动手练习——三层任务，层层递进】（08:15–08:45）

> 现在，请你完成以下任务：

> **【基础任务】单结构应用（20 分钟）**  
> 1. **闰年判断**：输入年份，输出是否闰年；测试 2000, 1900, 2024；  
> 2. **阶乘计算**：输入 n（0≤n≤12），输出 n!；验证 0! = 1。

> **【进阶任务】多结构混合（25 分钟）**  
> 1. **斐波那契**：输入 n，输出前 n 项；测试 n=0,1,5；  
> 2. **成绩统计**：输入 5 个分数，统计 A/B/C/D/F 人数；  
>    - 用 `for` 读 5 次；  
>    - 用 `if-else if` 分类。

> **【陷阱任务】错误修复（10 分钟）**  
> 1. 修复无限循环代码（`i--` + `i++`）；  
> 2. 修复悬空 else 代码；  
> 3. 补全闰年条件。

---

### 【第 5 步：调试策略——如何快速定位逻辑错误？】（08:45–08:55）

> **策略 1：插入计数器防死循环**  
> ```cpp
> int iter = 0;
> while (cond && iter++ < 1000) { ... } // 最多1000次
> ```

> **策略 2：打印中间变量**  
> ```cpp
> for (int i=0; i<5; i++) {
>     std::cout << "DEBUG: i=" << i << "\n"; // 观察变化
>     // ... logic
> }
> ```

> **策略 3：手动模拟小输入**  
> - 对斐波那契，手动算 n=3 的输出；  
> - 对阶乘，手算 4! = 24，再对比程序。

> **记住**：**调试不是猜，而是用证据缩小错误范围**。

---

### 【第 6 步：总结 + 衔接下一阶段】（08:55–09:00）

> 今天我们完成了控制流的“实战演练”：  
>  
> ✅ 解决了闰年、阶乘、斐波那契等经典问题；  
> ✅ 修复了无限循环、悬空 else、边界遗漏；  
> ✅ 掌握了调试策略。  
>  
> 但循环中还有两个“秘密武器”你没用过：  
> - **`break`**：立即跳出循环；  
> - **`continue`**：跳过本次剩余代码，进入下一次。  
>  
> 下一阶段（09:00–10:30），我们将学习 **`break` 与 `continue`**，  
> 让你的循环控制更加精细、高效。  
>  
> 而你今天写的循环，将成为它们的最佳试验场。  
>  
> 准备好升级你的循环控制力了吗？我们继续。

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“示范 → 陷阱 → 练习 → 调试”为实战闭环；  
> - ✅ 生活化比喻：“食谱 vs 煮面”贯穿循环场景；  
> - ✅ 动手为王：三层任务（基础/进阶/陷阱），含经典问题与错误修复；  
> - ✅ 防错前置：强调无限循环、悬空 else、边界遗漏三大陷阱；  
> - ✅ 衔接清晰：为09:00–10:30的 `break` / `continue` 教学提供循环基础。

