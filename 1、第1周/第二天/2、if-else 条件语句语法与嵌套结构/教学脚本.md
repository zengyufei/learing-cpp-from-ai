## **if-else 条件语句语法与嵌套结构**  

---

### 【第 1 步：语法引入——让程序学会“如果…就…”】（01:30–01:45）

> 同学，昨天你的程序只会说固定的话。  
>  
> 今天，它将学会**根据情况做不同事**——靠的就是 **`if-else` 语句**。  
>  
> 基本语法非常简单：
> ```cpp
> if (条件) {
>     // 条件为 true 时执行
> } else {
>     // 条件为 false 时执行
> }
> ```
>  
> 例如：
> ```cpp
> if (age >= 18) {
>     std::cout << "Adult\n";
> } else {
>     std::cout << "Minor\n";
> }
> ```
>  
> **关键点**：  
> - `条件` 必须是 **布尔表达式**（你昨天已掌握）；  
> - 花括号 `{}` **包裹要执行的代码块**；  
> - `else` 是可选的，但强烈建议用于处理“其他情况”。

---

### 【第 2 步：执行模型——程序如何“走岔路”？】（01:45–02:00）

> 程序执行到 `if` 时，会：  
> 1. 计算 `条件` 的值；  
> 2. 如果为 `true`，**跳进 `if` 块**，执行完后**跳过 `else`**；  
> 3. 如果为 `false`，**跳过 `if` 块**，**进入 `else` 块**（如果有）。  
>  
> **生活化比喻**：  
> > “`if-else` 像地铁闸机：  
> > - 刷卡成功（true）→ 开闸通行；  
> > - 刷卡失败（false）→ 报警提示。  
> > 你不可能既通行又报警——程序也一样，只走一条路。”  
>  
> 而多级 `else if` 就像**多级安检**：
> ```cpp
> if (score >= 90) {
>     grade = 'A';
> } else if (score >= 80) {
>     grade = 'B';
> } else if (score >= 70) {
>     grade = 'C';
> } else {
>     grade = 'F';
> }
> ```
> 一旦某级通过，就不再检查后面——**顺序很重要**！

---

### 【第 3 步：悬空 else 警示——省略花括号的致命陷阱】（02:00–02:15）

> 现在，看这段“危险代码”：
> ```cpp
> if (a > 0)
>     if (b > 0)
>         std::cout << "Both positive\n";
>     else
>         std::cout << "b not positive\n";
> ```
>  
> 你可能以为 `else` 属于外层 `if`，但 **C++ 规定：`else` 总是配对最近的 `if`**。  
>  
> 所以实际结构是：
> ```cpp
> if (a > 0) {
>     if (b > 0) {
>         ...
>     } else {          // ← 这个 else 属于内层 if！
>         ...
>     }
> }
> ```
>  
> **后果**：当 `a <= 0` 时，整个块被跳过—— `else` 根本不会执行！  
>  
> **解决方案**：**永远用花括号**，即使只有一行：
> ```cpp
> if (a > 0) {
>     if (b > 0) {
>         std::cout << "Both positive\n";
>     }
> } else {
>     std::cout << "a not positive\n";
> }
> ```
>  
> **记住**：**花括号不是装饰，是防御未来错误的铠甲**。

---

### 【第 4 步：多级分支示范——成绩评级系统】（02:15–02:30）

> 我们来写一个完整的成绩评级程序：

> **需求**：  
> - 90–100 → A  
> - 80–89 → B  
> - 70–79 → C  
> - 60–69 → D  
> - 0–59 → F  
> - 其他 → “Invalid score”

> **代码**：
> ```cpp
> int score;
> std::cout << "Enter score (0-100): ";
> std::cin >> score;

> if (score >= 90 && score <= 100) {
>     std::cout << "A\n";
> } else if (score >= 80) {  // 不用写 <=89，因为 >=90 已排除
>     std::cout << "B\n";
> } else if (score >= 70) {
>     std::cout << "C\n";
> } else if (score >= 60) {
>     std::cout << "D\n";
> } else if (score >= 0) {
>     std::cout << "F\n";
> } else {
>     std::cout << "Invalid score!\n";
> }
> ```

> **设计技巧**：  
> - 条件按**从高到低**排列；  
> - 利用 `else if` 的**互斥性**，省略上界检查；  
> - 用 `else` 捕获所有异常输入。

---

### 【第 5 步：动手实践——你来写，我来查】（02:30–02:55）

> 现在轮到你了：

> **【基础任务】单/双分支（20 分钟）**  
> 1. 编写：输入整数，若 >0 输出 “Positive”，否则 “Non-positive”；  
> 2. 编写：输入年龄，≥18 输出 “Adult”，否则 “Minor”；  
> 3. **故意省略花括号**，制造悬空 else，观察行为。

> **【进阶任务】成绩评级（25 分钟）**  
> 4. 实现上述完整评级系统；  
> 5. 测试边界值：90, 89, 80, 79, 0, -1, 101；  
> 6. 确保无效输入有提示。

> **【陷阱任务】条件重叠修复（10 分钟）**  
> 修复以下代码（输入 95 会输出两行）：
> ```cpp
> if (score > 80) std::cout << "B\n";
> if (score > 90) std::cout << "A\n"; // 错！
> ```
> → 改为 `else if`。

---

### 【第 6 步：即时反馈——为什么顺序不能乱？】（02:55–03:00）

> 有同学问：“为什么 `score >= 90` 要放最前面？”  
>  
> 答：因为 `else if` 是**顺序检查、一旦命中就跳过后续**。  
>  
> 如果你写：
> ```cpp
> if (score >= 80) { ... } // 先检查
> else if (score >= 90) { ... } // 永远不会执行！
> ```
> 那么 95 分会先命中 `>=80`，直接输出 B，**永远不会检查 A 条件**。  
>  
> **在 `else if` 链中，顺序 = 优先级**。  
>  
> 记住：**高优先级条件放前面，低优先级放后面**。

---

### 【第 7 步：总结 + 衔接下一阶段】（03:00）

> 今天我们让程序学会了“做选择”：  
>  
> ✅ 掌握了 `if-else` 语法与执行流程；  
> ✅ 避免了悬空 else 陷阱；  
> ✅ 实现了多级成绩评级系统。  
>  
> 但光有“选择”还不够——程序还需要“重复做事”。  
>  
> 下一阶段（03:30–04:30），我们将学习 **如何用 `if` + `while` 实现输入验证重试**：  
> - 用户输错选项，自动回到输入；  
> - 无效分数，提示重输。  
>  
> 而你今天写的 `else` 默认分支，将成为错误处理的关键。  
>  
> 准备好让你的程序从“一次判断”迈向“持续交互”了吗？我们继续。

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“语法 → 执行 → 陷阱 → 示范 → 实践”为逻辑链；  
> - ✅ 生活化比喻：“地铁闸机”“多级安检”贯穿分支讲解；  
> - ✅ 动手为王：三层任务（基础/进阶/陷阱），含悬空 else 制造与修复；  
> - ✅ 防错前置：强调花括号强制、条件顺序、边界覆盖；  
> - ✅ 衔接清晰：为03:30–04:30的输入重试机制提供 `if` 条件判断能力支撑。
