## **while 循环执行模型与典型应用场景**  

---

### 【第 1 步：需求驱动——如何让程序“回到过去”？】（04:30–04:40）

> 同学，上一阶段你给单位转换器加了输入验证，但一旦输错，程序就退出。  
>  
> 用户会抱怨：“我只是手滑输错，为什么要我重新启动？”  
>  
> 你需要一个**时光机**——让程序在出错时，**跳回输入步骤，重新开始**。  
>  
> 这个“时光机”，叫 **`while` 循环**。  
>  
> 今天这 90 分钟，我们要让程序学会**重复做事**，直到用户做对为止。  
>  
> 准备好赋予你的代码“耐心”了吗？

---

### 【第 2 步：语法引入——while 的基本结构】（04:40–04:50）

> `while` 的语法极其简单：
> ```cpp
> while (条件) {
>     // 循环体：重复执行的代码
> }
> ```
>  
> **执行流程**：  
> 1. 检查 `条件`；  
> 2. 如果为 `true`，执行 `{}` 中的代码；  
> 3. 执行完后，**自动回到第 1 步**；  
> 4. 如果 `条件` 为 `false`，**跳出循环**，继续往下走。  
>  
> **关键区别**：  
> - `if`：判断一次，最多执行一次；  
> - `while`：判断多次，可能执行 0 次、1 次或 100 万次。  
>  
> **生活化比喻**：  
> > “`if` 像红绿灯——看一眼，决定走或停；  
> > `while` 像跑步机——只要你没按停止，它就一直转。”

---

### 【第 3 步：循环三要素——避免无限循环的铁律】（04:50–05:10）

> 所有健壮的 `while` 循环，必须包含**三要素**：

> **1. 初始化**（起点）  
> ```cpp
> int count = 0; // 初始值
> ```

> **2. 条件**（继续的规则）  
> ```cpp
> while (count < 10) { ... }
> ```

> **3. 更新**（向终点靠近）  
> ```cpp
> count++; // 每次循环必须更新！
> ```

> **如果缺了更新**：
> ```cpp
> int i = 0;
> while (i < 5) {
>     std::cout << i << "\n";
>     // 忘记 i++！
> }
> ```
> → 程序会**无限输出 0**，直到你强制终止。  
>  
> **这就是无限循环——C++ 不会阻止你，它只会忠实执行你的错误指令**。

---

### 【第 4 步：典型场景示范——从重试到猜数字】（05:10–05:30）

> **场景 1：选项重试（解决上一阶段痛点）**
> ```cpp
> int choice;
> while (true) { // 无限循环，靠 break 退出
>     std::cout << "Enter 1 or 2: ";
>     std::cin >> choice;
>     if (choice == 1 || choice == 2) {
>         break; // 跳出循环
>     }
>     std::cout << "Invalid! Try again.\n";
> }
> ```

> **场景 2：安全输入重试（处理非数字）**
> ```cpp
> double x;
> while (true) {
>     std::cin >> x;
>     if (std::cin.fail()) {
>         std::cout << "Not a number! Try again: ";
>         std::cin.clear(); // 重置错误状态
>         std::cin.ignore(1000, '\n'); // 跳过无效输入
>     } else {
>         break; // 输入成功，退出
>     }
> }
> ```

> **场景 3：猜数字游戏核心**
> ```cpp
> const int ANSWER = 42;
> int guess;
> while (guess != ANSWER) {
>     std::cin >> guess;
>     if (guess < ANSWER) std::cout << "Too small\n";
>     else if (guess > ANSWER) std::cout << "Too big\n";
> }
> std::cout << "Correct!\n";
> ```

> **注意**：这些例子中，`break` 是**受控退出**，不是无限循环。

---

### 【第 5 步：动手实践——你来写“有耐心”的程序】（05:30–05:55）

> 现在轮到你了：

> **【基础任务】循环基础（20 分钟）**  
> 1. 用 `while` 输出 1 到 10；  
> 2. 计算 1 到 100 的和；  
> 3. **故意省略更新**，制造无限循环，再修复。

> **【进阶任务】改造单位转换器（35 分钟）**  
> 4. 将选项输入改为 `while (true)` + `break`；  
> 5. 将长度输入改为带 `cin.fail()` 处理的重试循环；  
> 6. 测试：  
>    - 输入 `3` → 提示重试；  
>    - 输入 `abc` → 提示“Not a number”，继续重试；  
>    - 输入 `1, 10` → 正常输出 25.4。

> **【陷阱任务】死循环诊断（10 分钟）**  
> 7. 分析：
>    ```cpp
>    int i = 5;
>    while (i > 0) {
>        std::cout << i << "\n";
>        i--; // 若注释此行？
>    }
>    ```
> 8. 修复猜数字游戏中“输字母导致死循环”的问题。

---

### 【第 6 步：即时反馈——为什么 clear () 和 ignore () 必不可少？】（05:55–05:58）

> 有同学问：“为什么输 `abc` 给 `int` 后，后续 `cin` 都失效？”  
>  
> 因为：  
> - `cin` 进入 **fail 状态**，拒绝再读；  
> - 缓冲区残留 `abc`，下次读还是它。  
>  
> **`std::cin.clear()`**：重置 fail 状态；  
> **`std::cin.ignore(1000, '\n')`**：跳过缓冲区中最多 1000 字符，直到换行。  
>  
> 这两行是**处理输入错误的标准组合拳**——今天先用，第 3 周深究。

---

### 【第 7 步：总结 + 衔接下一阶段】（05:58–06:00）

> 今天我们让程序学会了“耐心”：  
>  
> ✅ 掌握了 `while` 语法与三要素；  
> ✅ 实现了输入重试、猜数字等典型场景；  
> ✅ 避免了无限循环陷阱。  
>  
> 但 `while` 虽强大，写计数循环却略显啰嗦。  
>  
> 下一阶段（06:00–07:30），我们将学习 **`for` 循环**——  
> 专为“已知次数重复”设计的简洁语法。  
>  
> 而你今天写的 `while (count < 10) { ... count++; }`，  
> 将变成一行优雅的 `for (int i=0; i<10; i++)`。  
>  
> 准备好升级你的循环工具箱了吗？我们继续。

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“需求 → 语法 → 三要素 → 场景 → 实践”为逻辑链；  
> - ✅ 生活化比喻：“红绿灯 vs 跑步机”贯穿循环讲解；  
> - ✅ 动手为王：三层任务（基础/进阶/陷阱），含无限循环制造与修复；  
> - ✅ 防错前置：强调更新缺失、输入流状态处理、`clear()` + `ignore()` 组合；  
> - ✅ 衔接清晰：为06:00–07:30的 `for` 循环教学提供对比基础，为猜数字游戏提供核心逻辑。

