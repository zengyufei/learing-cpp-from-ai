## **综合应用 if 实现输入验证与错误重试机制**

---

#### **本阶段学习目标**  
1. 能结合 `if` 条件判断与布尔标志变量，实现基础输入有效性验证；  
2. 理解“错误重试”需求的本质：**在条件不满足时重复执行输入逻辑**；  
3. 初步感知循环结构的必要性，为下一阶段 `while` 学习埋下认知伏笔；  
4. 掌握使用 `std::cin.fail()` 检测输入流错误，并结合 `if` 进行初步处理；  
5. 能改造已有项目（如单位转换器），增加健壮的输入验证与用户友好提示。

---

#### **本阶段知识点分解**

##### 1. **输入验证的核心逻辑**
- **验证维度**：  
  - **类型正确性**：用户输入是否匹配变量类型（如 `int` 输入字母）；  
  - **语义有效性**：输入值是否在合理范围内（如选项 1–3，分数 0–100）。
- **检测手段**：  
  - 类型错误：`if (std::cin.fail())`；  
  - 语义错误：`if (choice < 1 || choice > 3)`。
- **处理策略（本阶段）**：  
  - 发现错误 → 输出提示 → **程序退出**（`return 1;`）；  
  - （为下一阶段铺垫）理想策略：**循环重试**（将在04:30后学习）。

##### 2. **布尔标志变量的引入**
- **作用**：记录输入是否有效，控制程序流程；  
- **典型模式**：
  ```cpp
  bool valid_input = false;
  // ... 读取输入 ...
  if (/* 类型和语义均有效 */) {
      valid_input = true;
  }
  if (!valid_input) {
      std::cout << "Invalid input!\n";
      return 1;
  }
  ```
- **优势**：逻辑清晰，便于扩展（未来可替换为循环条件）。

##### 3. **std:: cin.Fail () 机制初探**
- **原理**：当 `cin >> x` 无法解析输入为 `x` 的类型时，`cin` 进入“失败状态”；  
- **检测**：`std::cin.fail()` 返回 `true` 表示失败；  
- **局限性（本阶段不深究）**：  
  - 失败后缓冲区残留字符，需 `clear()` 和 `ignore()` 清理（第 3 周详述）；  
  - 本阶段仅用于**检测并退出**，不处理恢复。

##### 4. **项目改造：单位转换器增强版**
- **原始问题**：输错选项（如 4）或非数字，程序静默失败或崩溃；  
- **增强需求**：  
  - 选项必须为 1 或 2；  
  - 长度值必须为有效数字；  
  - 任一错误，提示并退出。
- **改造要点**：  
  - 读取选项后，用 `if` 检查是否为 1 或 2；  
  - 读取长度后，用 `if (std::cin.fail())` 检查类型；  
  - 使用清晰错误提示（“Invalid option” vs “Invalid number”）。

##### 5. **生活化比喻强化理解**
- **输入验证像安检**：  
  > “`cin >> x` 是 X 光机——如果行李（输入）不符合规格（类型），警报（fail ()）就响；  
  > `if` 是安检员——听到警报，就拦下旅客（退出程序）。”  
- **错误重试像自助售票机**：  
  > “输错车次？机器不会关机，而是说‘请重试’——这就是循环要做的事。”

---

#### **本阶段动手练习任务**

- **【基础任务】独立输入验证器（20 分钟）**  
  1. 编写程序：要求用户输入 1–3 之间的整数；  
  2. 用 `if` 检查：  
     - 若 `cin.fail()` → 输出 “Not a number!”；  
     - 若数字不在 1–3 → 输出 “Out of range!”；  
     - 否则输出 “Valid!”；  
  3. 任一错误，程序退出。

- **【进阶任务】改造单位转换器（30 分钟）**  
  1. 基于第 1 天代码，增加两层验证：  
     - 选项验证：必须为 1 或 2；  
     - 数值验证：`cin.fail()` 检测；  
  2. 错误提示区分类型：  
     - “Invalid option (must be 1 or 2)”  
     - “Invalid number (must be numeric)”  
  3. 验证以下用例：  
     - 正常：1, 10 → 25.4  
     - 异常：4 → 选项错误  
     - 异常：1, abc → 数值错误

- **【陷阱任务】缓冲区残留初探（10 分钟）**  
  1. 运行：输入 `1.5` 给 `int choice`；  
  2. 观察：`choice` 得 1，但小数点 `.5` 残留在缓冲区；  
  3. 讨论：为什么下一个 `cin >> length` 会失败？（为第 3 周埋伏笔）

---

#### **跨阶段综合小测/项目**  
- 本阶段输入验证能力将直接用于 **04:30–06:00 的 `while` 循环教学**：  
  - 学生将把此处的“退出”逻辑升级为“重试”；  
- 同时支撑 **15:00–16:30 的猜数字游戏** 中的无效输入处理。

---

#### **与前后阶段的知识衔接说明**

- **前置依赖**：01:30–03:00 阶段已掌握 `if-else`，本阶段将其**应用于真实输入场景**；  
- **后继支撑**：  
  - 04:30–06:00 将引入 `while`，把“退出”改为“循环重试”；  
  - 07:30–09:00 的编码训练将包含更复杂的输入验证（如闰年输入范围）；  
- **螺旋上升点**：  
  - 第 3 周“函数封装”将把输入验证提取为 `getValidInt(min, max)` 函数；  
  - 第 7 周“异常处理”将用 `try-catch` 替代 `if-fail()` 模式。

--- 

> 本阶段虽未引入循环，但通过“验证+退出”模式，让学生亲身体验“错误重试”的需求缺口，为 `while` 学习建立强烈动机。必须通过亲手改造项目，理解输入验证是可靠程序的基石，而非可选装饰。