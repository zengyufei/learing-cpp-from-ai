## **综合应用 if 实现输入验证与错误重试机制**  

---

### 【第 1 步：问题重现——你的程序会被“搞崩溃”吗？】（03:30–03:40）

> 同学，打开你昨天写的单位转换器，试试这个操作：  
>  
> 输入：`3`（选项）  
> 然后输入：`abc`（长度）  
>  
> 发生了什么？  
> - 程序可能输出 `0`；  
> - 或直接跳过输入；  
> - 甚至静默退出。  
>  
> **这不是 bug，而是“未验证输入”的必然结果**。  
>  
> 今天这 60 分钟，我们要给程序装上**安检门**——  
> **任何非法输入，要么被拦截，要么被友好提示**。  
>  
> 而工具，就是你刚学会的 `if`。

---

### 【第 2 步：验证逻辑——两层防护网】（03:40–03:50）

> 输入验证有两层：
>  
> **第一层：类型正确性**  
> - 用户是否输入了**合法数字**？  
> - 检测：`if (std::cin.fail())`  
>   → 如果 `cin` 无法把输入转成变量类型，它会“拉警报”。
>  
> **第二层：语义有效性**  
> - 数字是否在**合理范围**？  
> - 示例：选项必须是 `1` 或 `2`，不能是 `3` 或 `-1`；  
> - 检测：`if (choice != 1 && choice != 2)`
>  
> **生活化比喻**：  
> > “`cin.fail()` 是 X 光机——检测行李是否含金属（类型错误）；  
> > `if (choice != 1 && ...)` 是人工安检——检查你是否带了禁止物品（语义错误）。  
> > 两关都过，才能登机。”

---

### 【第 3 步：标志变量——让程序“记住”是否合法】（03:50–04:00）

> 我们用一个 `bool` 变量记录输入是否有效：
> ```cpp
> bool valid = true;
> 
> std::cin >> choice;
> if (std::cin.fail()) {
>     std::cout << "Not a number!\n";
>     valid = false;
> } else if (choice != 1 && choice != 2) {
>     std::cout << "Option must be 1 or 2!\n";
>     valid = false;
> }
> 
> if (!valid) {
>     return 1; // 异常退出
> }
> ```
>  
> **为什么用标志变量**？  
> - 避免多重 `return`，逻辑更清晰；  
> - 为未来升级为“循环重试”做准备（只需把 `if (!valid)` 改成 `while (!valid)`）。

---

### 【第 4 步：项目改造示范——单位转换器增强版】（04:00–04:10）

> 看改造后的核心逻辑：
> ```cpp
> // 1. 读取选项
> int choice;
> std::cout << "Choose (1: in→cm, 2: cm→in): ";
> std::cin >> choice;
> 
> // 2. 验证选项
> if (std::cin.fail() || (choice != 1 && choice != 2)) {
>     if (std::cin.fail()) {
>         std::cout << "Error: Please enter a number.\n";
>     } else {
>         std::cout << "Error: Option must be 1 or 2.\n";
>     }
>     return 1;
> }
> 
> // 3. 读取长度（同样验证）
> double length;
> std::cout << "Enter length: ";
> std::cin >> length;
> if (std::cin.fail()) {
>     std::cout << "Error: Length must be numeric.\n";
>     return 1;
> }
> 
> // 4. 执行转换...
> ```
>  
> **关键改进**：  
> - 错误提示**区分类型**；  
> - 任一错误，**立即退出**，不继续执行；  
> - 代码结构清晰：输入 → 验证 → 处理。

---

### 【第 5 步：动手实践——你来加固你的程序】（04:10–04:25）

> 现在，请你动手：

> **【基础任务】独立验证器（15 分钟）**  
> 1. 编写程序：要求输入 1–3 的整数；  
> 2. 用 `if` 检查：  
>    - `cin.fail()` → “Not a number!”  
>    - 数字不在 1–3 → “Out of range!”  
> 3. 任一错误，`return 1;`。

> **【进阶任务】改造单位转换器（20 分钟）**  
> 4. 在你第 1 天的代码基础上增加验证；  
> 5. 确保两类错误有**不同提示**；  
> 6. 测试用例：  
>    - ✅ `1, 10` → `25.4`  
>    - ❌ `4` → “Option must be 1 or 2”  
>    - ❌ `1, abc` → “Length must be numeric”

---

### 【第 6 步：伏笔埋设——为什么不能“重试”？】（04:25–04:28）

> 你可能想问：“为什么不让用户重试，而是直接退出？”  
>  
> 因为——**你还没有‘时光机’**。  
>  
> 要实现“输错重来”，你需要一个能**跳回前面代码**的结构。  
>  
> 而这个结构，叫 **`while` 循环**。  
>  
> 下一阶段（04:30–06:00），我们就来学习它。  
>  
> **带着这个问题进入下一课：如何让程序“回到过去”？**

---

### 【第 7 步：总结 + 衔接下一阶段】（04:28–04:30）

> 今天我们完成了程序的“第一道防线”：  
>  
> ✅ 用 `if` 实现了类型与语义双重验证；  
> ✅ 改造单位转换器，提升健壮性；  
> ✅ 建立了“输入必须验证”的工程意识。  
>  
> 但防御不是终点——**最好的体验是允许用户纠正错误**。  
>  
> 下一阶段，我们将引入 **`while` 循环**，让你的程序学会“耐心等待正确输入”。  
>  
> 而你今天写的验证逻辑，只需一行改动，就能升级为重试机制。  
>  
> 准备好获得“时光机”了吗？我们继续。

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“问题 → 验证 → 标志 → 改造 → 伏笔”为逻辑链；  
> - ✅ 生活化比喻：“X 光机+人工安检”贯穿输入验证讲解；  
> - ✅ 动手为王：两项任务（独立验证器+项目改造），含明确测试用例；  
> - ✅ 防错前置：强调 `cin.fail()` 使用、错误分类提示；  
> - ✅ 衔接清晰：为04:30–06:00的 `while` 教学埋下“重试需求”伏笔，标志变量设计支持无缝升级。
