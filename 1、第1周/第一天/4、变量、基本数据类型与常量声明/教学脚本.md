## **变量、基本数据类型与常量声明**  

---

### 【第 1 步：引入动机——程序不能只会“说话”，还要会“记事”】（04:30–04:40）

> 同学，到目前为止，你的程序只会说固定的话，比如 “Hello, World!”。  
>  
> 但现实中的程序需要**记住数据**：用户的年龄、商品的价格、开关的状态……  
>  
> 在 C++ 里，我们用 **变量** 来“记事”，用 **数据类型** 来告诉编译器：“我要记什么类型的东西”。  
>  
> 今天这 90 分钟，我们要给你的程序装上“记忆能力”——从只会说话的喇叭，变成会思考的助手。  
>  
> 而这一切，从四个基本类型开始：**整数、小数、字符、真假**。

---

### 【第 2 步：类型体系讲解——C++ 的“快递盒”系统】（04:40–05:00）

> C++ 不允许你说“给我一个变量”，而不说“它是什么类型”。  
>  
> 为什么？因为 C++ 要提前知道：**这个变量占多少内存？怎么解释里面的比特？**  
>  
> 我们有四类基础“快递盒”：

> **1. 整数盒（int, short, long）**  
> - 用来装没有小数的数字：年龄、人数、计数器；  
> - 最常用的是 `int`（通常占 4 字节，范围约 -20 亿到 +20 亿）；  
> - 如果你确定不会负数，可以用 `unsigned int`（0 到 40 亿）。

> **2. 小数盒（float, double）**  
> - `float` 是“普通保温箱”（4 字节，精度约 7 位）；  
> - `double` 是“高精度恒温箱”（8 字节，精度 15 位以上）；  
> - **默认用 `double`**，除非你明确需要节省内存。

> **3. 字符盒（char）**  
> - 只能装一个字母、数字或符号，比如 `'A'`、`'7'`、`'$'`；  
> - 注意：用**单引号**！双引号是字符串（那是另一个故事）。

> **4. 真假盒（bool）**  
> - 只有两个值：`true`（真）或 `false`（假）；  
> - 用来表示开关、状态、条件结果。

> **生活化比喻**：  
> > “想象你要寄东西：  
> > - 寄一封信？用 `char` 小信封；  
> > - 寄一台电脑？用 `double` 加厚箱；  
> > - 寄 100 个 U 盘？用 `int` 标准箱；  
> > - 寄‘是否同意’的回执？用 `bool` 明信片。  
> >  
> > 你必须提前告诉快递员用哪种盒子——C++ 就是那个一丝不苟的快递员。”

---

### 【第 3 步：变量声明与初始化——给盒子贴标签】（05:00–05:15）

> 声明一个变量，就是：**选盒子 + 贴名字 +（最好）放东西**。  
>  
> 语法模板：  
> ```cpp
> 类型 变量名 = 初始值;
> ```
>  
> 示例：
> ```cpp
> int age = 25;
> double price = 99.99;
> char grade = 'A';
> bool is_ready = true;
> ```
>  
> **重要规则**：  
> - 名字必须以字母或下划线开头，不能是关键字（如 `int x;` ✅，`int 1st;` ❌）；  
> - **强烈建议声明时就初始化**！否则盒子里是“上一个用户留下的垃圾”。

> **演示危险**：  
> ```cpp
> int garbage;
> std::cout << garbage << std::endl; // 输出？可能是 -123456789！
> ```
> 这就是**未初始化变量**——C++ 不会帮你清空盒子，它假设你“知道自己在干什么”。

---

### 【第 4 步：常量（const）——不可更改的契约】（05:15–05:25）

> 有些值，一旦设定就不该变，比如 π、光速、最大重试次数。  
>  
> 这时我们用 `const`：
> ```cpp
> const double PI = 3.14159265;
> const int MAX_ATTEMPTS = 3;
> ```
>  
> **特点**：  
> - 必须在声明时初始化；  
> - 之后任何赋值都会导致**编译错误**；  
> - 编译器可优化（比如直接把 `PI` 替换成 3.14159265）。

> **对比练习**：  
> - Python 中 `x = 10` 可随时改成 `x = 20`；  
> - C++ 中 `const int x = 10;` 是真正的“铁律”——改一个字，编译器就罢工。

> **命名惯例**：常量通常全大写，用下划线分隔：`MAX_BUFFER_SIZE`。

---

### 【第 5 步：动手实验——用 sizeof 量盒子】（05:25–05:45）

> 现在，请你动手验证：

> **【基础任务】声明并输出（15 分钟）**  
> 1. 在 `main` 函数中声明：  
>    - `int year = 2025;`  
>    - `double temp = -5.5;`  
>    - `char initial = 'C';`  
>    - `bool is_coding = true;`  
> 2. 用 `std::cout` 输出它们的值；  
> 3. 用 `sizeof` 打印每个类型的字节数：
>    ```cpp
>    std::cout << "int: " << sizeof(int) << " bytes\n";
>    ```

> **【进阶任务】常量与垃圾值（15 分钟）**  
> 4. 定义 `const double LIGHT_SPEED = 299792458.0;`，尝试写 `LIGHT_SPEED = 300000000;` → 观察编译错误；  
> 5. 声明 `int x;`（不初始化），输出 `x` 的值 → 记录你看到的“垃圾数字”。

> **【陷阱任务】边界实验（10 分钟）**  
> 6. 执行：
>    ```cpp
>    unsigned char c = 300;
>    std::cout << (int)c << std::endl; // 输出？（应为 44，因 300 % 256 = 44）
>    ```
> 7. 执行：
>    ```cpp
>    std::cout << (0.1 + 0.2 == 0.3) << std::endl; // 输出？（通常是 0，即 false！）
>    ```

---

### 【第 6 步：即时反馈——为什么 0.1 + 0.2 ≠ 0.3？】（05:45–05:55）

> 如果你看到 `(0.1 + 0.2 == 0.3)` 输出 `0`，别慌——**这不是 bug，是浮点数的本质**。  
>  
> 计算机用二进制表示小数，而 0.1 在二进制里是无限循环小数（就像 1/3 在十进制里是 0.333...）。  
>  
> 所以 `0.1 + 0.2` 实际存储的是一个**近似值**，不完全等于 `0.3`。  
>  
> **正确做法**：比较浮点数要用“误差范围”：
> ```cpp
> bool equal = std::abs(a - b) < 1e-9;
> ```
> （这个技巧我们第 9 周再深入）
>  
> 而 `unsigned char c = 300;` 输出 44，是因为 `char` 只能存 0–255，300 超了，就“绕回”：300 - 256 = 44。  
>  
> **这些不是 C++ 的缺陷，而是你必须理解的底层现实**。

---

### 【第 7 步：总结 + 衔接下一阶段】（05:55–06:00）

> 今天我们完成了程序的“记忆系统”搭建：  
>  
> ✅ 掌握了四大基本类型；  
> ✅ 学会了声明变量与常量；  
> ✅ 亲手观察了垃圾值、溢出、浮点精度陷阱。  
>  
> 但光有记忆还不够——程序还需要**和用户对话**。  
>  
> 下一阶段（06:00–07:30），我们将学习 `std::cin` 和 `std::cout` 的完整用法，让你的程序能**读取用户输入，并动态响应**。  
>  
> 而你今天声明的变量，就是接收用户数据的“容器”。  
>  
> 准备好让你的程序活起来了吗？我们继续。

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“记忆能力”为线索组织类型→变量→常量；  
> - ✅ 生活化比喻：“快递盒”贯穿类型讲解；  
> - ✅ 动手为王：三项分层练习（基础/进阶/陷阱），含 `sizeof` 实验；  
> - ✅ 防错前置：主动暴露未初始化、溢出、浮点比较等经典陷阱；  
> - ✅ 衔接清晰：为下一阶段“输入输出”提供数据容器（变量）。

（脚本结束，可无缝进入 06:00–07:30 的标准输入输出教学）