## **运算符与表达式——C++ 的数学与逻辑引擎**

---

#### **本阶段学习目标**  
1. 掌握 C++ 中常用运算符的分类、优先级与结合性：算术、关系、逻辑、赋值、自增/自减；  
2. 能正确书写和计算复合表达式，理解运算顺序对结果的影响；  
3. 深入理解 `++i` 与 `i++` 的语义差异及其在表达式中的行为；  
4. 能通过括号显式控制运算顺序，避免依赖默认优先级导致的逻辑错误；  
5. 初步建立“表达式求值”的执行模型意识，为后续条件语句和循环奠定基础。

---

#### **本阶段知识点分解**

##### 1. **运算符分类与基本用法**
- **算术运算符**：`+`, `-`, `*`, `/`, `%`（取模）  
  - 整数除法截断小数（`5 / 2 == 2`）；  
  - `%` 仅用于整数，结果符号与被除数一致（`-7 % 3 == -1`）。
- **关系运算符**：`==`, `!=`, `<`, `>`, `<=`, `>=`  
  - 返回 `bool` 类型（`true` / `false`）；  
  - 禁止连写（`a < b < c` 在 C++ 中合法但逻辑错误，应写为 `a < b && b < c`）。
- **逻辑运算符**：`&&`（与）、`||`（或）、`!`（非）  
  - 支持短路求值（`a && b`：若 `a` 为 `false`，则不计算 `b`）；  
  - 常用于组合多个条件。
- **赋值运算符**：`=`, `+=`, `-=`, `*=`, `/=`, `%=`  
  - 赋值是**表达式**，有返回值（可链式赋值：`a = b = 5;`）。

##### 2. **运算符优先级与结合性**
- **优先级从高到低（部分）**：  
  `()` → `++ --` → `* / %` → `+ -` → `< <= > >=` → `== !=` → `&&` → `||` → `=`  
- **结合性**：  
  - 大多数二元运算符左结合（`a - b - c == (a - b) - c`）；  
  - 赋值运算符右结合（`a = b = c == a = (b = c)`）。
- **生活化比喻**：  
  > “运算符优先级就像数学里的‘先乘除后加减’；  
  > 结合性就像排队——左结合是从左往右算，右结合是从右往左分。”

##### 3. **自增/自减运算符：前置 vs 后置**
- **前置（`++i`）**：先加 1，再返回新值；  
- **后置（`i++`）**：先返回原值，再加 1；  
- **关键区别示例**：
  ```cpp
  int i = 5;
  int a = ++i; // a=6, i=6
  int j = 5;
  int b = j++; // b=5, j=6
  ```
- **陷阱场景**：
  ```cpp
  int x = 1;
  int y = x++ + ++x; // 行为未定义！避免在单表达式中多次修改同一变量
  ```

##### 4. **表达式求值与类型提升**
- **整数提升**：`char`、`short` 在运算中自动转为 `int`；  
- **浮点优先**：`int + double → double`；  
- **常见错误**：
  - `5 / 2 * 3.0 == 6.0`（先整除得 2，再转 double）；  
  - `(5 / 2) * 3.0 != 5 / (2 * 3.0)`（括号改变顺序）。

##### 5. **常见错误与陷阱**
- ❌ 混淆 `=` 与 `==`（赋值 vs 比较）；  
- ❌ 在条件中写 `if (x = 5)`（应为 `==`），编译器可能警告但不报错；  
- ❌ 依赖复杂优先级而不加括号（如 `a && b == c` 实际是 `a && (b == c)`，但易误解）；  
- ❌ 在表达式中多次修改同一变量（未定义行为）。

---

#### **本阶段动手练习任务**

- **【基础任务】表达式计算与输出（30 分钟）**  
  1. 声明变量 `int a = 10, b = 3;`；  
  2. 分别计算并输出：  
     - `a + b`, `a - b`, `a * b`, `a / b`, `a % b`；  
     - `a > b`, `a == b`, `a != b`；  
     - `(a > 5) && (b < 5)`；  
  3. 验证整数除法截断行为。

- **【进阶任务】自增/自减实验（30 分钟）**  
  1. 编写程序：
     ```cpp
     int x = 5;
     std::cout << "x++ = " << x++ << ", now x = " << x << std::endl;
     int y = 5;
     std::cout << "++y = " << ++y << ", now y = " << y << std::endl;
     ```
  2. 尝试：
     ```cpp
     int z = 2;
     int w = z++ + ++z; // 观察输出（不同编译器可能不同！）
     ```
     → 讨论：为什么这是危险的？

- **【陷阱任务】优先级与逻辑陷阱（30 分钟）**  
  1. 预测以下表达式结果，再验证：
     ```cpp
     bool r1 = 3 < 5 < 2;      // 是 true 还是 false？
     bool r2 = (3 < 5) < 2;    // 明确分组
     int r3 = 10 / 2 * 3;      // 15 还是 1？
     int r4 = 10 / (2 * 3);    // 对比
     ```
  2. 修复错误代码：
     ```cpp
     int score = 85;
     if (score = 100) {        // 意图是比较！
         std::cout << "Perfect!\n";
     }
     ```

---

#### **跨阶段综合小测/项目**  
- 本阶段内容将直接用于 **第 5 天“简易计算器”项目** 的核心计算逻辑：  
  - 支持四则运算需正确处理运算符优先级；  
  - 若因 `=` 误用为 `==` 或整数除法导致功能错误，视为未达标；  
- 同时为 **第 2 天“条件语句”** 提供表达式基础（如 `if (a > b && c != 0)`）。

---

#### **与前后阶段的知识衔接说明**

- **前置依赖**：07:30–09:00 阶段已能编写含简单表达式的程序，本阶段**系统化表达式规则**；  
- **后继支撑**：  
  - 10:30–12:00 的“类型转换”将解释 `int + double` 的隐式提升；  
  - 第 2 天“if/else”将大量使用关系与逻辑表达式；  
- **螺旋上升点**：  
  - 第 6 周“运算符重载”将回溯本阶段运算符语义，赋予自定义类型运算能力；  
  - 第 16 周“性能优化”将分析 `++i` 与 `i++` 在自定义类型中的效率差异。

--- 

> 本阶段是程序从“静态计算”迈向“动态决策”的桥梁。运算符不是符号，而是**控制流的基石**。必须通过亲手验证优先级、自增行为、类型混合，建立对表达式求值顺序的精确直觉，避免未来在复杂条件中栽跟头。