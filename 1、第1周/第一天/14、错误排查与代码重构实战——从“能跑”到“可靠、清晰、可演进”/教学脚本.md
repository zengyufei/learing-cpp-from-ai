## **错误排查与代码重构实战——从“能跑”到“可靠、清晰、可演进”**  

---

### 【第 1 步：任务引入——一段“看起来能跑”的危险代码】（19:30–19:40）

> 同学，你已经能写出功能正确的程序。  
>  
> 但现实中，**最危险的代码不是报错的，而是“安静地错”**。  
>  
> 今天我们要分析一段“病态代码”——它能编译、能运行、甚至对某些输入输出“看起来正确”，  
> 但**内部藏着致命逻辑错误**。  
>  
> 你的任务是：  
> ✅ 找出错误；  
> ✅ 修复它；  
> ✅ 重构代码，让它不仅正确，而且清晰、健壮、易于未来扩展。  
>  
> 这不是练习，而是**真实世界的代码审查（Code Review）模拟**。

---

### 【第 2 步：错误诊断——为什么 212°F 不等于 100°C？】（19:40–20:00）

> 看这段温度转换器：
> ```cpp
> #include <iostream>
> using namespace std;
> int main() {
>     int mode;
>     cout << "1:F2C 2:C2F: ";
>     cin >> mode;
>     double t;
>     cin >> t;
>     double r;
>     if (mode == 1) {
>         r = (t - 32) * 5 / 9;   // ← 问题在这里！
>     } else {
>         r = t * 9 / 5 + 32;
>     }
>     cout << r << endl;
>     return 0;
> }
> ```

> **测试用例 1**：输入 `1`（F→C），然后 `32` → 输出 `0` ✅（巧合正确）；  
> **测试用例 2**：输入 `1`，然后 `212` → 输出 `0` ❌（应为 100）！

> **为什么？**  
> 因为 `5 / 9` 是**整数除法**，结果为 `0`！  
> 整个表达式变成 `(212 - 32) * 0 = 0`。  
>  
> **这就是逻辑错误的典型特征**：  
> - 程序不报错；  
> - 对部分输入“碰巧”正确；  
> - 对其他输入静默失败。  
>  
> 如果你只测了 32°F，你会以为程序完美——**这就是测试覆盖的重要性**。

---

### 【第 3 步：重构原则——好代码的三个标准】（20:00–20:10）

> 修复错误只是第一步。真正的工程师还要让代码**可维护、可演进**。  
>  
> 好代码的三个标准：  
>  
> ✅ **正确性**：行为符合需求；  
> ✅ **清晰性**：命名、结构、注释让人一眼看懂；  
> ✅ **可演进性**：未来加功能（如支持开尔文）时，改动最小。  
>  
> **生活化比喻**：  
> > “原始代码像手写便签：‘买牛奶、鸡蛋’——你能看懂，但别人可能误解；  
> > 重构后像购物清单：‘ dairy: milk (1 L), eggs (dozen) ’——结构清晰，未来加‘cheese’也方便。”

---

### 【第 4 步：分步示范——从“病态”到“健康”】（20:10–20:30）

> 我们一步步重构：

> **第一步：修复逻辑错误**
> ```cpp
> // 错误
> r = (t - 32) * 5 / 9;
> // 正确
> r = (t - 32) * 5.0 / 9.0;
> ```

> **第二步：移除 `using namespace std;`**
> ```cpp
> std::cout << "1: F to C, 2: C to F: ";
> ```

> **第三步：命名升级**
> - `mode` → `conversionMode`  
> - `t` → `inputTemp`  
> - `r` → `resultTemp`

> **第四步：提取常量**
> ```cpp
> const double FAHRENHEIT_TO_CELSIUS_FACTOR = 5.0 / 9.0;
> const double CELSIUS_TO_FAHRENHEIT_FACTOR = 9.0 / 5.0;
> ```

> **第五步：格式化 + 注释**
> ```cpp
> // Convert based on user selection
> if (conversionMode == 1) {
>   resultTemp = (inputTemp - 32.0) * FAHRENHEIT_TO_CELSIUS_FACTOR;
> } else {
>   resultTemp = inputTemp * CELSIUS_TO_FAHRENHEIT_FACTOR + 32.0;
> }
> ```

> **最终效果**：功能不变，但**意图清晰、错误风险低、未来易扩展**。

---

### 【第 5 步：动手实践——你来当“代码医生”】（20:30–20:55）

> 现在轮到你了：

> **【核心任务】诊断与重构（50 分钟）**  
> 1. 复制原始“病态代码”；  
> 2. 测试 `212 → 100`，确认错误；  
> 3. 修复整数除法；  
> 4. 按以下要求重构：  
>    - 移除 `using namespace std;`；  
>    - 使用清晰变量名；  
>    - 定义 `const double` 常量；  
>    - 2 空格缩进，运算符加空格；  
>    - 添加注释说明公式；  
>    - 输入前有明确提示。  
> 5. 测试用例：  
>    - `1, 212` → `100`  
>    - `2, 100` → `212`  
>    - `1, -459.67` → `-273.15`（绝对零度）

> **【进阶任务】为未来埋种子（10 分钟）**  
> 在代码末尾加注释：
> ```cpp
> // TODO: 第3周将提取为独立函数：
> // double fahrenheitToCelsius(double f);
> // double celsiusToFahrenheit(double c);
> ```

---

### 【第 6 步：即时反馈——为什么命名和常量如此重要？】（20:55–21:00）

> 有同学问：“功能对了就行，何必改名？”  
>  
> 答：**代码是写给人看的，机器只关心 0 和 1**。  
>  
> - `r = (t - 32) * 5 / 9;` → 你三个月后回看，会问：“t 是什么？R 是什么？”  
> - `resultTemp = (inputTemp - 32) * FACTOR;` → 一眼看懂。  
>  
> 而 `5.0 / 9.0` 写成常量，未来要改精度（如用更高精度系数），**只需改一行**。  
>  
> **在工程中，可读性 = 可靠性 = 开发速度**。  
>  
> 你今天多花 5 分钟写清楚，未来团队省 5 小时 debug。

---

### 【第 7 步：总结 + 衔接下一阶段】（21:00）

> 今天我们完成了 C++ 第一天的**最后一次实战**：  
>  
> ✅ 诊断并修复了隐蔽的逻辑错误；  
> ✅ 将“能跑”的代码升级为“可靠、清晰、可演进”；  
> ✅ 建立了代码审查的初步意识。  
>  
> 但这还不是终点。  
>  
> 下一阶段（21:00–22:30），我们将进行 **当日知识全景复盘**：  
> - 绘制“第 1 天知识地图”；  
> - 完成 10 道自测题；  
> - 提交所有代码与反思。  
>  
> 而你今天重构的温度转换器，将成为复盘的典型案例。  
>  
> 恭喜你，即将走完 C++ 学习的第一天——从环境搭建到项目重构，你已经踏出了坚实的第一步。  
>  
> 现在，去修复那段“安静出错”的代码吧！

---

> 📌 **教学原则达成检查**：  
> - ✅ 结构先行：以“诊断 → 修复 → 重构 → 演进”为工程闭环；  
> - ✅ 生活化比喻：“手写便签 vs 结构化清单”贯穿重构理念；  
> - ✅ 动手为王：核心任务覆盖错误修复+风格升级+未来准备；  
> - ✅ 防错前置：强调整数除法陷阱、模糊命名风险、测试覆盖必要性；  
> - ✅ 衔接清晰：为21:00–22:30复盘提供案例，为第 3 周函数提取埋下“TODO”伏笔。

