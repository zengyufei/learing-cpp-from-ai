太好了！我们现在进入 **1.4.3：new[] 与 delete[] — 数组专用配对**。

这是 C++ 动态内存管理中一个**极易出错但至关重要的细节**。许多开发者（包括有经验者）会混淆 `new`/`delete` 与 `new[]`/`delete[]`，导致**未定义行为（UB）**——可能程序看似正常，实则内存已损坏。本课将帮你建立清晰的配对规则，并理解其底层原理。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（数组内存地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 1.4.1–1.4.2 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.4.3：new[] 与 delete[] — 数组专用配对

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.4.1–1.4.2（栈与堆内存）、Java 数组经验  
> **后续衔接**：1.4.4（malloc/free vs new/delete）、3.9（标准容器增强）  
> **预计耗时**：2–3 小时

---

### 🧭 一、结构先行：动态数组内存地图

```
1.4.3 new[] 与 delete[]
├── 1. 为什么需要专用配对？
│   ├── 1.1 数组需要存储元素个数
│   ├── 1.2 构造/析构多个对象
│   └── 1.3 与单对象 new/delete 的差异
├── 2. new[] 表达式
│   ├── 2.1 语法：new T[N]
│   ├── 2.2 分配内存 + 调用 N 次构造函数
│   └── 2.3 返回 T*（指向首元素）
├── 3. delete[] 表达式
│   ├── 3.1 语法：delete[] p
│   ├── 3.2 调用 N 次析构函数 + 释放内存
│   └── 3.3 必须配对 new[]
├── 4. 常见错误配对
│   ├── 4.1 new[] + delete（非数组）→ UB
│   ├── 4.2 new + delete[]（数组）→ UB
│   └── 4.3 为什么 UB？（底层原理）
├── 5. 与 Java 数组的对比
└── 6. 现代 C++ 替代方案
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能正确使用 `new[]`/`delete[]` 管理动态数组，理解其与单对象 `new`/`delete` 的差异，并避免配对错误。
- **Measurable**：完成 2 道基础题 + 2 道陷阱题，能解释为何 `new[]` + `delete` 是 UB。
- **Achievable**：通过“公寓楼”比喻理解数组元数据存储。
- **Relevant**：这是避免隐蔽内存错误的关键。
- **Time-bound**：1–2 天内完成。

---

### 🌍 三、生活化比喻：公寓楼管理系统

> 想象一个**智能公寓楼**：
>
> - **单对象（new/delete） = 独栋别墅**  
>   - 租一栋（`new`），退一栋（`delete`）  
>   - 无额外记录
>
> - **数组（new[]/delete[]） = 公寓楼**  
>   - 租一整栋楼（`new int[100]`）  
>   - **物业（内存管理器）在地下室记录**：  
>     - “这栋楼有 100 户”  
>   - 退租时（`delete[]`），物业：  
>     1. 通知 100 户搬出（调用 100 次析构）  
>     2. 拆楼（释放内存）  
>     3. 清除地下室记录
>
> - **错误配对**：  
>   - `new[]` + `delete` = 只通知 1 户搬出，拆整栋楼 → **其他 99 户被活埋（析构未调用）**  
>   - `new` + `delete[]` = 试图读取不存在的地下室记录 → **物业系统崩溃（UB）**

> 💡 **关键认知**：**`new[]` 存储了元素个数，`delete[]` 依赖它正确析构**。

---

### 📚 四、知识点分解

#### 1. 为什么需要专用配对？
- **元数据存储**：`new T[N]` 通常在返回指针**之前**存储 `N`（具体实现依赖编译器）
- **构造/析构次数**：
  - `new T[N]` → 调用 `N` 次 `T` 的构造函数
  - `delete[] p` → 调用 `N` 次 `T` 的析构函数（需知道 `N`）
- **单对象无此需求**：`new T` 只构造 1 次，`delete p` 只析构 1 次

#### 2. `new[]` 表达式
- **语法**：
  ```cpp
  int* arr = new int[10];          // 基本类型
  MyClass* objs = new MyClass[5];  // 类类型（调用 5 次默认构造）
  ```
- **返回值**：指向首元素的指针（`T*`）
- **初始化**（C++11）：
  ```cpp
  int* arr = new int[5]{1,2,3,4,5}; // 列表初始化
  ```

#### 3. `delete[]` 表达式
- **语法**：
  ```cpp
  delete[] arr;
  delete[] objs;
  ```
- **必须配对**：每个 `new T[N]` 必须用 `delete[]`
- **对 `nullptr` 安全**：`delete[] nullptr;` 合法

#### 4. 常见错误配对（UB！）
| 错误 | 后果 |
|------|------|
| `new T[N]` + `delete p` | **只调用 1 次析构**，其余 `N-1` 个对象泄漏（若 T 有资源） |
| `new T` + `delete[] p` | **尝试读取不存在的 N**，可能 crash 或破坏堆 |

> ⚠️ **UB 表现**：  
> - 可能“正常工作”（基本类型无析构）  
> - 可能 crash（类类型析构未调用）  
> - 可能静默内存损坏（最危险！）

#### 5. 与 Java 数组的对比
| 特性 | C++ 动态数组 | Java 数组 |
|------|-------------|----------|
| **分配** | `new T[N]` | `new T[N]` |
| **释放** | **手动 `delete[]`** | **自动 GC** |
| **长度** | 无内置 `.length` | 有 `.length` 字段 |
| **类型安全** | 无运行时检查 | 有边界检查 |

#### 6. 现代 C++ 替代方案
- **基本类型数组** → `std::vector<T>`
- **对象数组** → `std::vector<T>`（自动管理内存 + 析构）
- **唯一场景用 `new[]`**：实现容器类（如 `std::vector` 本身）

> 💡 **黄金法则**：**永远不要裸 `new[]`/`delete[]`，用 `std::vector`**

---

### 💻 五、动手为王：可运行示例

#### 示例 1：正确配对
```cpp
#include <iostream>

class Tracker {
public:
    Tracker() { std::cout << "Construct\n"; }
    ~Tracker() { std::cout << "Destruct\n"; }
};

int main() {
    // 正确：new[] + delete[]
    Tracker* arr = new Tracker[3]; // 3 次构造
    delete[] arr;                 // 3 次析构
    return 0;
}
```
> ✅ 输出：
> ```
> Construct
> Construct
> Construct
> Destruct
> Destruct
> Destruct
> ```

#### 示例 2：错误配对（UB！）
```cpp
#include <iostream>

int main() {
    // 危险：new[] + delete（非数组）
    Tracker* arr = new Tracker[3];
    delete arr; // UB！只调用 1 次析构
    // 其他 2 个对象未析构 → 资源泄漏
    return 0;
}
```
> ⚠️ 输出（可能）：
> ```
> Construct
> Construct
> Construct
> Destruct  // 只有 1 次！
> ```

#### 示例 3：基本类型（看似安全但仍是 UB）
```cpp
#include <iostream>

int main() {
    int* arr = new int[5]{1,2,3,4,5};
    delete arr; // UB！但基本类型无析构，可能“正常”
    // 不要依赖此行为！
    return 0;
}
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **安全数组管理**  
   - 用 `new int[10]` 创建数组，初始化为 0-9，打印，然后 `delete[]`

2. **配对验证**  
   - 编写函数 `create_int_array(size_t n)`，返回动态数组，确保配对

#### 🔸 进阶题
3. **Tracker 数组**  
   - 用 `new Tracker[5]` 创建数组，验证 5 次构造/析构

4. **现代替代**  
   - 用 `std::vector<Tracker>` 重写 Tracker 数组示例

#### ⚠️ 陷阱题（迁移误区）
5. **“基本类型无所谓吧？”**  
   - Q: `int* p = new int[100]; delete p;` 安全吗？  
   - A: ❌ **不安全**！  
     → 虽然基本类型无析构，但**仍是 UB**  
     → 可能破坏堆管理器内部结构

6. **“delete 和 delete[] 一样吧？”**  
   - Q: 以下代码合法吗？
     ```cpp
     int* p = new int;
     delete[] p;
     ```
   - A: ❌ **非法**！  
     → `new` 分配的单对象，无元素个数记录  
     → `delete[]` 会读取无效内存 → UB

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **配对错误** | 用 `std::vector` 避免裸数组 |
| **调试 UB** | 用 AddressSanitizer 检测（`-fsanitize=address`） |
| **遗留代码** | 代码审查时重点检查 `new`/`delete` 配对 |
| **现代替代** | `std::vector` 是动态数组的唯一推荐方式 |
| **性能** | `std::vector` 与裸数组性能相同（零开销抽象） |

> 💡 **现代 C++ 建议**：
> - **永远用 `std::vector<T>`** 代替 `new T[N]`
> - **若必须裸数组**：封装为 RAII 类（如 `Array<T>`）
> - **教学目的外**：不要在生产代码中使用 `new[]`/`delete[]`

---

### 🔁 八、螺旋复习

- **衔接 1.4.2**：单对象 `new`/`delete` vs 数组 `new[]`/`delete[]`
- **衔接 1.7**：C 风格数组 vs `std::vector`
- **Java 经验**：C++ 无自动数组回收，必须手动配对
- **当日复习**：默写配对规则（`new`→`delete`, `new[]`→`delete[]`）

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么编译器不自动检测配对错误？”
   - “`std::vector` 内部如何管理内存？”
2. **概念图**：画出 `new[]` 的内存布局（含元素个数存储）
3. **扮演教师**：向同事解释“为什么 `new[]` + `delete` 是 UB”

---

### 🔍 十、复盘清单

✅ 我能正确使用 `new[]`/`delete[]`  
✅ 我理解配对错误的 UB 后果  
✅ 我知道现代 C++ 用 `std::vector` 替代  
✅ 我能避免基本类型的配对误区  
✅ 我明白元数据存储的原理

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 动态数组内存管理的核心知识**！

接下来你可以：
1. **继续学习 1.4.4 malloc / free 与 new / delete 的区别（构造/析构调用）**
2. **请求生成「动态数组安全使用速查卡」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！