非常好！我们现在对 **Phase 1：C++ 语法基础（120 小时）** 进行**三级知识地图细化**，保持“结构先行”原则——只展示知识骨架，不涉及代码示例、练习题或教学细节，确保你先掌握整体脉络。

每个 KU（如 1.1）将展开为若干子知识点（1.1.1、1.1.2…），若某主题特别复杂（如“指针与引用”），可继续下探至四级（1.3.2.1 等），但整体仍维持“地图”属性。

---

## 🗺️ Phase 1：C++ 语法基础（120 小时）  
> 目标：建立 C++ 编程的底层心智模型，理解其与 Java 在编译、内存、类型、模块组织上的根本差异。

---

### **1.1 C++ 编译与构建模型**
1.1.1 源文件（.cpp）与头文件（.h/.hpp）的分工  
1.1.2 预处理阶段：#include、#define、条件编译  
1.1.3 编译阶段：翻译单元（Translation Unit）概念  
1.1.4 链接阶段：符号解析、重复定义错误（ODR）  
1.1.5 静态链接 vs 动态链接（简要）  
1.1.6 与 Java 对比：.java → .class → JVM vs .cpp → .o → 可执行文件  
1.1.7 构建工具简介：g++ 命令行、Makefile 基础、CMake 入门概念  

---

### **1.2 基本类型与字面量**
1.2.1 内置类型：bool, char, signed/unsigned char, short, int, long, long long  
1.2.2 浮点类型：float, double, long double  
1.2.3 类型别名：typedef vs using（C++11）  
1.2.4 字面量后缀：U（unsigned）、L（long）、LL（long long）、F（float）  
1.2.5 布尔上下文转换规则（与 Java 的严格 boolean 对比）  
1.2.6 size_t 与 ptrdiff_t：标准库中的无符号/有符号尺寸类型  
1.2.7 类型大小与对齐：sizeof 运算符、平台差异（32/64 位）  

---

### **1.3 指针与引用**
1.3.1 地址操作符 & 与解引用操作符 *  
1.3.2 指针声明语法：int* p vs int *p vs int * p（风格差异）  
1.3.3 空指针：NULL vs nullptr（C++11 引入）  
1.3.4 指针算术：+、-、[] 操作的内存偏移含义  
1.3.5 引用（Reference）语义：别名机制、必须初始化、不可重绑定  
1.3.6 指针 vs 引用对比表（初始化、重赋值、空值、算术）  
1.3.7 与 Java 引用的本质区别：Java 无指针算术、无栈对象引用、无裸指针  
1.3.8 多级指针（int**）与指针数组（int* arr[]）初步概念  

---

### **1.4 栈与堆内存管理**
1.4.1 自动存储（栈）：局部变量生命周期  
1.4.2 动态存储（堆）：new / delete 表达式  
1.4.3 new[] 与 delete[]：数组专用配对  
1.4.4 malloc / free 与 new / delete 的区别（构造/析构调用）  
1.4.5 内存泄漏定义与常见场景（忘记 delete、异常路径）  
1.4.6 悬空指针（Dangling Pointer）与野指针（Wild Pointer）  
1.4.7 栈 vs 堆性能与大小限制对比  
1.4.8 与 Java 对比：Java 无栈对象（除基本类型）、全由 GC 管理堆  

---

### **1.5 函数基础**
1.5.1 函数声明 vs 函数定义  
1.5.2 参数传递方式：值传递、指针传递、引用传递  
1.5.3 默认参数：声明中指定、从右向左省略  
1.5.4 函数重载：基于参数类型/数量的重载决议  
1.5.5 重载 vs 重写（override）区分（后者属 Phase 2）  
1.5.6 内联函数（inline）：建议编译器展开、替代宏函数  
1.5.7 函数作用域与链接性：static 函数（内部链接）  
1.5.8 main 函数签名：int main() vs int main(int argc, char* argv[])  

---

### **1.6 结构体 (struct) 与 POD**
1.6.1 struct 定义与成员访问（. 操作符）  
1.6.2 struct 与 class 的默认访问权限差异（public vs private）  
1.6.3 成员函数在 struct 中的定义（初步）  
1.6.4 聚合类型（Aggregate）与初始化：{ } 初始化规则  
1.6.5 POD（Plain Old Data）概念：兼容 C 的布局与行为  
1.6.6 与 Java 对比：Java 无 struct，用 class + final 字段模拟  
1.6.7 内存布局：成员顺序、填充（padding）、对齐要求  

---

### **1.7 C 风格数组与字符串**
1.7.1 固定大小数组声明：int arr[10];  
1.7.2 数组退化为指针：函数参数中的数组实为指针  
1.7.3 C 风格字符串：以 '\0' 结尾的 char 数组  
1.7.4 标准库函数：strlen, strcpy, strcat, strcmp 风险分析  
1.7.5 缓冲区溢出（Buffer Overflow）原理与危害  
1.7.6 与 Java 对比：Java String 不可变、自动边界检查、无 '\0'  
1.7.7 安全替代方案预告：std::string（Phase 2 引入）  

---

### **1.8 枚举类型**
1.8.1 传统 enum：无作用域、隐式转换为 int  
1.8.2 作用域枚举（enum class）：强类型、需显式作用域访问  
1.8.3 枚举底层类型指定：enum Color : uint8_t  
1.8.4 枚举值初始化：显式赋值、自动递增  
1.8.5 与 Java enum 对比：Java enum 是完整类，支持方法和字段  
1.8.6 使用场景建议：何时用 enum class 而非宏或 const  

---

### **1.9 const 正确性**
1.9.1 const 变量：编译期常量（若初始化为字面量）  
1.9.2 const 指针：指向常量（const int*）、指针常量（int* const）、两者皆常（const int* const）  
1.9.3 const 引用：绑定临时对象、延长生命周期  
1.9.4 函数参数中的 const：防止意外修改（const T&）  
1.9.5 const 作为接口契约：承诺不修改对象状态  
1.9.6 与 Java final 对比：final 仅限制引用/变量重赋，不保证对象不可变  

---

### **1.10 头文件机制与 include**
1.10.1 #include 指令：尖括号 <> vs 双引号 ""  
1.10.2 头文件卫士（Header Guards）：#ifndef / #define / #endif  
1.10.3 #pragma once（非标准但广泛支持）  
1.10.4 重复包含问题：符号重定义错误  
1.10.5 声明 vs 定义分离原则：头文件放声明，源文件放定义  
1.10.6 inline 函数与模板必须在头文件中定义  
1.10.7 循环依赖问题初步识别（后续用前置声明解决）  

---

### **1.11 命名空间 (namespace)**
1.11.1 namespace 定义与嵌套  
1.11.2 作用域解析操作符 ::  
1.11.3 using 声明：using std::cout;（引入单个名称）  
1.11.4 using 指令：using namespace std;（引入整个命名空间，慎用）  
1.11.5 无名命名空间（unnamed namespace）：替代 static 全局变量/函数  
1.11.6 与 Java package 对比：namespace 无目录结构绑定，仅逻辑分组  
1.11.7 标准库命名空间：std  

---

### **1.12 输入输出流 (iostream)**
1.12.1 标准流对象：std::cin, std::cout, std::cerr, std::clog  
1.12.2 流插入 << 与提取 >> 操作符  
1.12.3 格式控制：std::endl vs '\n'、std::setw、std::setprecision  
1.12.4 流状态检查：fail(), bad(), eof(), good()  
1.12.5 文件流简介：std::ifstream / std::ofstream（仅概念，详细在 Phase 2）  
1.12.6 与 Java 对比：System.out.println vs cout <<；Java Scanner vs cin  
1.12.7 性能提示：同步关闭（std::ios::sync_with_stdio(false)）  

---

✅ **Phase 1 知识地图完成**：共 12 个 KU，下探至 3–4 级，总计约 **120+ 个原子知识点**。

---

## 🔜 下一步建议

现在你拥有了 **Phase 1 的完整三级知识骨架**。接下来你可以选择：

1. **进入 Phase 2 的三级知识地图细化**（C++ 进阶：类、RAII、模板等）  
2. **返回 Phase 1，选择某个 KU（如 1.3 指针与引用 或 1.4 内存管理）进行深度教学设计**（含代码、练习、陷阱题）  
3. **查看 Phase 1 与 Java 的系统性差异对照表**（帮助你预判迁移难点）

请告诉我你的下一步方向，我们将继续协同构建这份 480 小时的转型计划。