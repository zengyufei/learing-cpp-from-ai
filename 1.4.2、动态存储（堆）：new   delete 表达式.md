太好了！我们现在进入 **1.4.2：动态存储（堆）— new / delete 表达式**。

这是 C++ 手动内存管理的**核心机制**，也是与 Java GC 模型最根本的差异点。在 Java 中，你只需 `new` 对象，GC 会自动回收；而在 C++ 中，**`new` 必须配对 `delete`**，否则会导致**内存泄漏**。理解堆内存的分配与释放，是掌握 RAII、智能指针、以及编写无泄漏 C++ 代码的前提。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（堆内存地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 1.4.1 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.4.2：动态存储（堆）— new / delete 表达式

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.4.1（栈内存）、Java `new` 经验  
> **后续衔接**：1.4.3（new[] / delete[]）、2.3（RAII）、3.2（智能指针）  
> **预计耗时**：3–4 小时

---

### 🧭 一、结构先行：堆内存地图

```
1.4.2 动态存储（堆）
├── 1. 什么是动态存储？
│   ├── 1.1 堆（Heap）内存区域
│   ├── 1.2 new / delete 语法
│   └── 1.3 与 Java new 的根本差异
├── 2. new 表达式
│   ├── 2.1 分配内存 + 调用构造函数
│   ├── 2.2 返回指针（T*）
│   └── 2.3 失败处理（std::bad_alloc）
├── 3. delete 表达式
│   ├── 3.1 调用析构函数 + 释放内存
│   ├── 3.2 必须配对 new
│   └── 3.3 对 nullptr 安全
├── 4. 内存泄漏与悬空指针
│   ├── 4.1 忘记 delete → 泄漏
│   ├── 4.2 多次 delete → UB
│   └── 4.3 delete 后未置 nullptr → 悬空
├── 5. 与栈的对比
└── 6. 现代 C++ 替代方案
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能正确使用 `new`/`delete` 分配和释放堆内存，理解其与 Java `new` 的差异，并避免内存泄漏等陷阱。
- **Measurable**：完成 3 道基础题 + 2 道陷阱题，能诊断内存泄漏场景。
- **Achievable**：通过“租房”比喻理解手动内存管理。
- **Relevant**：这是掌握 RAII 和智能指针的基础。
- **Time-bound**：2 天内完成。

---

### 🌍 三、生活化比喻：租房系统

> 想象一个**城市租房系统**：
>
> - **Java = 全包公寓**  
>   - 你只需说 “`new Apartment()`”  
>   - 房东（GC） later 自动回收空房  
>   - **你不用关心**：何时退房、是否重复退房
>
> - **C++ = 手动租房**  
>   - `new Apartment()` = **租一套房**（分配内存 + 初始化）  
>   - 你**必须记住**：  
>     - **退房**（`delete`）  
>     - **不能重复退房**（多次 `delete` → UB）  
>     - **退房后别再用钥匙**（悬空指针）
>
> - **关键差异**：  
>   - Java：**自动退房**  
>   - C++：**手动退房，否则欠租（泄漏）**

> 💡 **关键认知**：**C++ 的 `new`/`delete` 是手动内存管理，必须严格配对**。

---

### 📚 四、知识点分解

#### 1. 什么是动态存储？
- **定义**：由程序员手动管理的内存区域（堆），用于存储**生命周期超越作用域**的对象。
- **语法**：
  ```cpp
  MyClass* p = new MyClass(); // 分配 + 构造
  delete p;                   // 析构 + 释放
  ```
- **与 Java `new` 的根本差异**：
  | 特性 | C++ `new` | Java `new` |
  |------|----------|-----------|
  | **内存位置** | 堆 | 堆 |
  | **释放方式** | **手动 `delete`** | **自动 GC** |
  | **泄漏风险** | 高（忘记 `delete`） | 低（循环引用除外） |
  | **确定性析构** | 是 | 否（`finalize()` 不可靠） |

#### 2. `new` 表达式
- **作用**：
  1. 在堆上分配足够内存（`sizeof(T)` 字节）
  2. 调用对象的**构造函数**
- **返回值**：指向对象的指针（`T*`）
- **失败处理**：
  - 默认抛出 `std::bad_alloc` 异常
  - 可用 `new (std::nothrow) T()` 返回 `nullptr`（不推荐）

#### 3. `delete` 表达式
- **作用**：
  1. 调用对象的**析构函数**
  2. 释放堆内存
- **必须配对**：每个 `new` 必须有且仅有一个 `delete`
- **对 `nullptr` 安全**：
  ```cpp
  int* p = nullptr;
  delete p; // 合法，无操作
  ```

#### 4. 常见陷阱
- **内存泄漏**：
  ```cpp
  void f() {
      MyClass* p = new MyClass();
      // 忘记 delete p; → 泄漏
  }
  ```
- **多次 `delete`**：
  ```cpp
  MyClass* p = new MyClass();
  delete p;
  delete p; // UB！可能 crash
  ```
- **悬空指针**：
  ```cpp
  MyClass* p = new MyClass();
  delete p;
  // p 仍指向已释放内存
  // *p = 10; // UB！
  ```
- **类型不匹配**：
  ```cpp
  Base* p = new Derived();
  delete p; // 若 Base 无虚析构函数 → UB！
  ```

#### 5. 与栈的对比
| 特性 | 堆（`new`/`delete`） | 栈（自动存储） |
|------|---------------------|---------------|
| **生命周期** | 手动管理 | 作用域绑定 |
| **分配速度** | 慢（内存管理器） | 极快（指针移动） |
| **大小限制** | 大（GB 级） | 小（MB 级） |
| **碎片** | 有 | 无 |
| **典型用途** | 大对象、跨作用域、动态结构 | 局部变量、小对象 |

#### 6. 现代 C++ 替代方案
- **单对象** → `std::unique_ptr<T>`
- **数组** → `std::vector<T>` 或 `std::unique_ptr<T[]>`
- **共享所有权** → `std::shared_ptr<T>`

> 💡 **黄金法则**：**优先栈对象，其次智能指针，最后裸 `new`/`delete`**

---

### 💻 五、动手为王：可运行示例

#### 示例 1：基本 new/delete
```cpp
#include <iostream>

class MyClass {
public:
    MyClass() { std::cout << "Constructed\n"; }
    ~MyClass() { std::cout << "Destructed\n"; }
};

int main() {
    MyClass* p = new MyClass(); // Constructed
    delete p;                   // Destructed
    return 0;
}
```

#### 示例 2：内存泄漏演示
```cpp
#include <iostream>

void leak() {
    MyClass* p = new MyClass(); // Constructed
    // 忘记 delete → Destructed never called
}

int main() {
    leak();
    std::cout << "Program ends, but memory leaked!\n";
    return 0;
}
```
> 🔍 用 Valgrind 检测：
> ```bash
> g++ -g leak.cpp -o leak
> valgrind ./leak
> ```

#### 示例 3：悬空指针危险
```cpp
#include <iostream>

int main() {
    int* p = new int(42);
    delete p;
    // p is now dangling
    // std::cout << *p << "\n"; // UB!可能输出42，可能 crash
    p = nullptr; // 安全做法：delete 后置 nullptr
    return 0;
}
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **安全分配/释放**  
   - 用 `new` 创建 `int`，赋值为 100，打印，然后 `delete`

2. **配对验证**  
   - 编写函数 `create_and_use()`，确保 `new` 和 `delete` 配对

#### 🔸 进阶题
3. **异常安全**  
   - 编写函数，`new` 两个对象，若第二个 `new` 失败，确保第一个被 `delete`

4. **nullptr 安全**  
   - 验证 `delete nullptr;` 是否安全

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“new 了就不用管了吧？”**  
   - Q: C++ 中 `MyClass* p = new MyClass();` 后，程序结束时会自动释放吗？  
   - A: ⚠️ **部分正确**：  
     - 操作系统会回收进程内存  
     - **但析构函数不会被调用**！  
     → 若析构中有重要操作（如文件 flush），会丢失数据

6. **“delete 和 Java GC 一样吧？”**  
   - Q: `delete p;` 后，`p` 会自动变 `nullptr` 吗？  
   - A: ❌ **不会**！`p` 仍是原地址（悬空指针）  
     → **必须手动 `p = nullptr;`**

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **内存泄漏** | 用 RAII/智能指针自动管理 |
| **多次 delete** | `delete` 后置 `p = nullptr` |
| **异常安全** | 用智能指针避免泄漏 |
| **调试** | 用 Valgrind / AddressSanitizer 检测泄漏 |
| **现代替代** | 优先 `std::unique_ptr` |

> 💡 **现代 C++ 建议**：
> - **永远不要裸 `new`/`delete`**（除非实现 RAII 类）
> - **用 `std::make_unique<T>()`**（C++14）安全创建
> - **异常安全**：智能指针在异常时自动释放

---

### 🔁 八、螺旋复习

- **衔接 1.4.1**：栈对象自动销毁 vs 堆对象手动管理
- **衔接 1.3.7**：C++ 手动内存 vs Java GC
- **Java 经验**：C++ 无自动回收，必须配对 `new`/`delete`
- **当日复习**：默写 `new`/`delete` 三大陷阱

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 不像 Java 那样自动回收堆内存？”
   - “`delete` 调用析构函数，但不调用构造函数，为什么？”
2. **概念图**：画出 `new`/`delete` 的内存操作流程
3. **扮演教师**：向同事解释“为什么 `delete` 后要置 `nullptr`”

---

### 🔍 十、复盘清单

✅ 我能正确使用 `new`/`delete`  
✅ 我理解 C++ 与 Java 内存管理的根本差异  
✅ 我知道内存泄漏、多次 delete、悬空指针的危险  
✅ 我会用现代 C++ 替代方案（智能指针）  
✅ 我明白手动内存管理的责任

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 动态存储（堆）的核心知识**！

接下来你可以：
1. **继续学习 1.4.3 new[] 与 delete[]：数组专用配对**
2. **请求生成「new/delete 安全检查清单」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！