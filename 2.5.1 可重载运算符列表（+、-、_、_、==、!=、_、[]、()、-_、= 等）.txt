太好了！我们现在进入 **2.5.1：可重载运算符列表（+、-、*、/、==、!=、<、[]、()、->、= 等）**。

这是 C++ **操作符重载**的起点，也是理解 C++ **统一表达式语法**的关键。作为 Java 开发者，你可能只能重载 `equals()`/`compareTo()`，而 C++ 允许重载**几乎所有运算符**，使自定义类型能像内置类型一样自然使用。掌握可重载运算符列表，是编写直观、易用 C++ 类的基础。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（运算符地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含基础/进阶/陷阱题）  
- ✅ 螺旋复习（衔接 Java 经验）  
- ✅ 主动 learning + 复盘

---

## 🎯 KU 2.5.1：可重载运算符列表

> **所属阶段**：Phase 2 — 面向对象编程  
> **前置知识**：Java `equals()`/`compareTo()` 经验  
> **后续衔接**：2.5.2（成员 vs 非成员重载）、2.5.3（常见运算符实现）  
> **预计耗时**：2–3 小时

---

### 🧭 一、结构先行：运算符地图

```
2.5.1 可重载运算符
├── 1. 可重载运算符
│   ├── 1.1 算术：+ - * / % ++ -- (unary)
│   ├── 1.2 比较：== != < > <= >=
│   ├── 1.3 赋值：= += -= *= /= %=
│   ├── 1.4 下标：[]
│   ├── 1.5 函数调用：()
│   ├── 1.6 成员访问：-> 
│   ├── 1.7 流插入/提取：<< >>
│   └── 1.8 逻辑：! && || (但通常不重载 && ||)
├── 2. 不可重载运算符
│   ├── 2.1 作用域：::
│   ├── 2.2 成员访问：. 
│   ├── 2.3 成员指针访问：.* 
│   └── 2.4 三元条件：?:
├── 3. 重载方式
│   ├── 3.1 成员函数（隐式 this）
│   └── 3.2 非成员函数（需友元访问私有成员）
├── 4. 与 Java 的对比
│   ├── 4.1 C++：运算符重载（语法糖）
│   └── 4.2 Java：仅方法（equals, compareTo）
├── 5. 最佳实践
    ├── 5.1 保持语义一致性（+ 应可交换）
    ├── 5.2 优先非成员函数（对称性）
    └── 5.3 避免过度重载（保持可读性）
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能列出主要可重载/不可重载运算符，理解其重载方式，并与 Java 对比。
- **Measurable**：完成 2 道基础题 + 2 道陷阱题，能解释为何 `.` 和 `::` 不可重载。
- **Achievable**：通过“语法糖工厂”比喻理解运算符重载。
- **Relevant**：这是编写直观 C++ API 的基础。
- **Time-bound**：1–2 天内完成。

---

### 🌍 三、生活化比喻：语法糖工厂

> 想象一个**语法糖工厂**：
>
> - **内置类型 = 标准糖**  
>   - `1 + 2` → 工厂直接生产
>
> - **自定义类型 = 定制糖**  
>   - `point1 + point2` → 工厂调用你的**定制配方**（重载函数）
>
> - **不可重载运算符 = 工厂禁止定制**  
>   - `obj.member` → 工厂规定必须直接访问（不能定制）
>
> - **Java 对比**：  
>   - Java = **只有标准糖和方法糖**（`point1.add(point2)`）  
>   - **C++ = 可定制所有糖**（`point1 + point2`）

> 💡 **关键认知**：**运算符重载是语法糖，使自定义类型像内置类型一样自然**。

---

### 📚 四、知识点分解

#### 1. 可重载运算符
- **算术运算符**：
  ```cpp
  MyClass operator+(const MyClass& a, const MyClass& b);
  MyClass& operator+=(const MyClass& other);
  MyClass operator++(); // 前置
  MyClass operator++(int); // 后置
  ```
- **比较运算符**：
  ```cpp
  bool operator==(const MyClass& a, const MyClass& b);
  bool operator<(const MyClass& a, const MyClass& b);
  ```
- **赋值运算符**：
  ```cpp
  MyClass& operator=(const MyClass& other); // 拷贝赋值
  MyClass& operator+=(const MyClass& other);
  ```
- **下标运算符**：
  ```cpp
  T& operator[](size_t index); // 成员函数
  ```
- **函数调用运算符**：
  ```cpp
  ReturnType operator()(Args... args); // 仿函数
  ```
- **成员访问运算符**：
  ```cpp
  PointerType operator->(); // 智能指针
  ```
- **流运算符**：
  ```cpp
  std::ostream& operator<<(std::ostream& os, const MyClass& obj);
  ```

#### 2. 不可重载运算符
- **作用域解析**：`::`（绑定编译期）
- **成员访问**：`.`（直接访问，无函数调用）
- **成员指针访问**：`.*`（同上）
- **三元条件**：`?:`（语法结构，非运算符）

> 📌 **为什么不可重载**？  
> 这些运算符**不涉及对象状态**，或**重载会破坏语言基础语义**。

#### 3. 重载方式
- **成员函数**：
  - 左操作数是 `*this`
  - 例如：`a += b` → `a.operator+=(b)`
- **非成员函数**：
  - 两个操作数显式参数
  - 例如：`a + b` → `operator+(a, b)`
  - 通常需要 `friend` 访问私有成员

#### 4. 与 Java 的对比
| 特性 | C++ | Java |
|------|-----|------|
| **运算符重载** | ✅ 几乎所有 | ❌ 仅 +（字符串拼接） |
| **比较** | `==` 重载 | `equals()` 方法 |
| **语法糖** | ✅ 丰富 | ⚠️ 有限 |

#### 5. 最佳实践
- **语义一致性**：
  - `a + b` 应等于 `b + a`（若适用）
  - `a == b` 应等于 `b == a`
- **优先非成员函数**：
  - 对称运算符（如 `+`）应为非成员，支持隐式转换
- **避免过度重载**：
  - 不要重载 `&&`/`||`（失去短路求值）
  - 不要重载 `&`（失去取地址语义）

> 💡 **现代 C++ 黄金法则**：  
> **“运算符重载是语法糖；保持语义一致；优先非成员函数”**

---

### 💻 五、动手为王：可运行示例

#### 示例 1：基本运算符重载
```cpp
#include <iostream>

class Point {
    double x_, y_;
    
public:
    Point(double x = 0, double y = 0) : x_(x), y_(y) {}
    
    // 成员函数：+=
    Point& operator+=(const Point& other) {
        x_ += other.x_;
        y_ += other.y_;
        return *this;
    }
    
    // 非成员函数：+
    friend Point operator+(Point a, const Point& b) {
        a += b;
        return a;
    }
    
    // 比较
    friend bool operator==(const Point& a, const Point& b) {
        return a.x_ == b.x_ && a.y_ == b.y_;
    }
    
    // 流输出
    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        return os << "(" << p.x_ << ", " << p.y_ << ")";
    }
};

int main() {
    Point p1(1, 2), p2(3, 4);
    Point p3 = p1 + p2; // 调用 operator+(p1, p2)
    p1 += p2;           // 调用 p1.operator+=(p2)
    
    std::cout << "p3: " << p3 << "\n";
    std::cout << "p1 == p3: " << (p1 == p3) << "\n";
    return 0;
}
```

#### 示例 2：不可重载运算符（编译错误）
```cpp
class MyClass {
public:
    // 以下尝试会编译错误！
    // MyClass operator.(const MyClass& other); // Error!
    // MyClass operator::(const MyClass& other); // Error!
};
```

#### 示例 3：Java 对比
```java
// Java: 无运算符重载
class Point {
    private double x, y;
    public Point(double x, double y) { this.x = x; this.y = y; }
    
    // 必须用方法
    public Point add(Point other) {
        return new Point(this.x + other.x, this.y + other.y);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Point) {
            Point p = (Point) obj;
            return this.x == p.x && this.y == p.y;
        }
        return false;
    }
}

// 使用
Point p1 = new Point(1, 2);
Point p2 = new Point(3, 4);
Point p3 = p1.add(p2); // 无 p1 + p2
boolean eq = p1.equals(p3);
```

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **运算符分类**  
   - 列出 5 个可重载和 3 个不可重载运算符

2. **重载方式**  
   - 为什么 `+` 通常用非成员函数，`+=` 用成员函数？

#### 🔸 进阶题
3. **下标运算符**  
   - 为 `MyVector` 类实现 `operator[]`

4. **流运算符**  
   - 为 `MyClass` 实现 `operator<<` 和 `operator>>`

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“Java 也能重载 + 吧？”**  
   - Q: Java 能重载 `+` 用于自定义类型吗？  
   - A: ❌ **不能**！  
     → Java **仅对 String 重载 `+`**  
     → **C++ 可对任何类型重载**

6. **“所有运算符都能重载吧？”**  
   - Q: C++ 能重载 `.` 和 `::` 吗？  
   - A: ❌ **不能**！  
     → 这些是**语言基础**，重载会破坏语义

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **语义一致性** | 重载应符合直觉（如 + 可交换） |
| **非成员优先** | 对称运算符用非成员（支持隐式转换） |
| **避免危险重载** | 不要重载 `&&`/`||`/`&` |
| **现代实践** | 用 `operator<=>`（C++20）简化比较 |

> 💡 **现代 C++ 黄金法则**：  
> **“运算符是语法糖，不是魔术；保持直觉，避免混淆”**

---

### 🔁 八、螺旋复习

- **Java 经验**：C++ 运算符重载比 Java 方法更直观  
- **当日复习**：默写可重载/不可重载运算符列表

---

### 🧠 九、主动 learning 任务

1. **自我提问**：
   - “如何用 operator() 实现仿函数？”
   - “C++20 spaceship operator <=> 如何简化比较？”
2. **概念图**：画出 C++ 与 Java 表达式语法对比
3. **扮演教师**：向同事解释“为什么 . 和 :: 不可重载”

---

### 🔍 十、复盘清单

✅ 我能列出主要可重载运算符  
✅ 我理解成员 vs 非成员重载  
✅ 我知道不可重载运算符及原因  
✅ 我明白与 Java 的对比  
✅ 我掌握运算符重载最佳实践

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 可重载运算符列表的核心知识**！

接下来你可以：
1. **继续学习 2.5.2 成员函数 vs 非成员函数重载（对称性问题）**
2. **请求生成「C++ 运算符重载速查卡」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！