太好了！我们现在正式进入 **Phase 1 的第一个原子知识点**：**1.1.1 源文件（.cpp）与头文件（.h/.hpp）**。

你将体验一次**完整、严谨、符合你所有学习偏好的教学单元**，严格遵循你强调的原则：

- ✅ **SMART 学习目标**
- ✅ **结构先行（先看地图）**
- ✅ **生活化比喻**
- ✅ **动手为王（可运行代码 + 分层练习）**
- ✅ **螺旋复习（含前序回顾与后续衔接）**
- ✅ **主动学习任务**
- ✅ **陷阱题 + 常见错误分析**
- ✅ **复盘与检测**

---

## 🎯 KU 1.1.1：源文件（.cpp）与头文件（.h/.hpp）

> **所属阶段**：Phase 1 — C++ 语法基础  
> **预计耗时**：3–4 小时（1.5h 学 + 1h 练 + 0.5h 复盘）  
> **前置知识**：无（这是 C++ 旅程的第一步）  
> **后续衔接**：1.1.2 预处理、1.10 头文件机制、1.5 函数声明分离

---

### 🧭 一、结构先行：知识地图

在深入细节前，先看“局部地图”：

```
1.1.1 源文件与头文件
├── 1. 为什么需要分离？（vs Java）
├── 2. .h 文件：放什么？（声明）
├── 3. .cpp 文件：放什么？（定义）
├── 4. 编译过程：如何协同工作？
├── 5. 命名惯例：.h vs .hpp
└── 6. 常见错误：重复定义、未包含、循环依赖
```

---

### 🎯 二、SMART 学习目标

- **Specific（具体）**：能独立创建 .h + .cpp 文件对，正确分离声明与定义，并用 g++ 成功编译链接。
- **Measurable（可衡量）**：完成 3 道基础题 + 2 道陷阱题，无编译/链接错误。
- **Achievable（可实现）**：通过类比 Java 包结构 + 图书馆借阅系统理解。
- **Relevant（相关）**：这是 C++ 多文件项目的基础，直接影响后续所有模块开发。
- **Time-bound（有时限）**：在 2 天内完成学习、练习与复盘。

---

### 🌍 三、生活化比喻：图书馆借阅系统

> 想象你是一家**大型图书馆的读者**：
>
> - **头文件（.h） = 图书目录卡**  
>   它告诉你：“这本书存在，书名是《C++ Primer》，作者是 Lippman，索书号是 TP312/C123”。  
>   → **它只描述“有什么”，不包含书的内容**。
>
> - **源文件（.cpp） = 书的实体**  
>   它包含《C++ Primer》的全部内容，你可以阅读、做笔记。  
>   → **它提供“具体实现”**。
>
> - **编译器 = 图书管理员**  
>   当你想借书（调用函数），你先查目录卡（#include "book.h"），然后管理员去书库找实体书（link book.cpp）。
>
> - **Java 对比**：Java 的 `.java` 文件既是目录卡又是书——编译后生成 `.class`，JVM 自动“链接”。  
>   **C++ 必须手动分开“目录”和“书”**，否则编译器会混乱。

---

### 📚 四、知识点分解

#### 1. 为什么需要分离？
- C++ 没有“包”或“模块”（C++20 前），靠文件组织代码。
- 分离好处：
  - **编译加速**：修改 .cpp 不需重编译所有依赖者（只需重新链接）
  - **接口隐藏**：用户只需看 .h，无需关心实现细节
  - **避免重复定义**：定义只在 .cpp 中出现一次

#### 2. 头文件（.h / .hpp）放什么？
✅ **应该放**：
- 函数**声明**（非定义）：`int add(int a, int b);`
- 类**声明**：`class Calculator { ... };`
- `#include` 依赖（如 `<iostream>`）
- `#define` 宏（不推荐，优先用 `constexpr`）

❌ **绝不放**：
- 函数**定义**（除非 inline / template）
- 全局变量**定义**（可放 `extern` 声明）

#### 3. 源文件（.cpp）放什么？
✅ **应该放**：
- 函数**定义**：`int add(int a, int b) { return a + b; }`
- 类成员函数**定义**
- 全局变量**定义**

#### 4. 编译过程简述
```bash
# 1. 编译每个 .cpp → .o（目标文件）
g++ -c math.cpp    # 生成 math.o
g++ -c main.cpp    # 生成 main.o

# 2. 链接所有 .o → 可执行文件
g++ math.o main.o -o app
```
- **编译阶段**：每个 .cpp 是独立“翻译单元”，需通过 #include 看到声明
- **链接阶段**：将所有定义“拼起来”，解决函数调用地址

#### 5. 命名惯例
- `.h`：传统 C 风格（也用于 C++）
- `.hpp`：明确表示 C++ 头文件（尤其含模板时）
- **无功能差异**，纯约定

---

### 💻 五、动手为王：可运行示例

#### 文件 1：`math.h`（头文件）
```cpp
// math.h
#ifndef MATH_H      // 头文件卫士（防重复包含）
#define MATH_H

// 函数声明（只告诉“有这个函数”）
int add(int a, int b);
int multiply(int a, int b);

#endif // MATH_H
```

#### 文件 2：`math.cpp`（源文件）
```cpp
// math.cpp
#include "math.h"   // 包含自己的头文件（好习惯！）

// 函数定义（实现细节）
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}
```

#### 文件 3：`main.cpp`（主程序）
```cpp
// main.cpp
#include <iostream>
#include "math.h"   // 包含头文件，看到函数声明

int main() {
    std::cout << "2 + 3 = " << add(2, 3) << "\n";
    std::cout << "4 * 5 = " << multiply(4, 5) << "\n";
    return 0;
}
```

#### 编译命令（终端执行）：
```bash
g++ -std=c++17 main.cpp math.cpp -o myapp
./myapp
```
> ✅ 输出：
> ```
> 2 + 3 = 5
> 4 * 5 = 20
> ```

---

### 📝 六、分层练习题

#### 🔹 基础题（掌握分离原则）
1. **创建 `greet.h` 和 `greet.cpp`**  
   - `greet.h`：声明 `void say_hello(const std::string& name);`  
   - `greet.cpp`：定义该函数，输出 `"Hello, name!"`  
   - `main.cpp`：调用它  
   - 要求：成功编译运行

2. **添加一个类 `Point`**  
   - `point.h`：声明 `class Point { int x, y; public: Point(int x, int y); void print(); };`  
   - `point.cpp`：定义构造函数和 `print()`  
   - 在 `main` 中创建 Point 并打印

#### 🔸 进阶题（理解编译模型）
3. **故意制造“未定义引用”错误**  
   - 在 `main.cpp` 中调用 `divide(10, 2)`，但不在任何 .cpp 中定义它  
   - 观察链接错误信息，理解“undefined reference to `divide`”

4. **尝试在 .h 中定义函数（非 inline）**  
   - 在 `math.h` 中直接写 `int subtract(int a, int b) { return a - b; }`  
   - 在两个 .cpp 中 #include 它，观察“重复定义”错误

#### ⚠️ 陷阱题（迁移 Java 误区）
5. **Java 风格错误：把所有代码放 .h**  
   ```cpp
   // WRONG.h
   #include <iostream>
   void log(const char* msg) {
       std::cout << msg << "\n";  // 定义在头文件！
   }
   ```
   - 在 `a.cpp` 和 `b.cpp` 中都 `#include "WRONG.h"`  
   - 问：会发生什么？如何修复？

---

### ⚠️ 七、注意事项与常见错误

| 错误类型 | 现象 | 原因 | 修复方案 |
|--------|------|------|--------|
| **重复定义** | `multiple definition of 'func'` | 函数定义出现在 .h 且被多文件包含 | 将定义移至 .cpp，或加 `inline` |
| **未定义引用** | `undefined reference to 'func'` | 声明了但未定义，或未链接 .cpp | 检查是否遗漏 .cpp 文件 |
| **未包含头文件** | `'add' was not declared in this scope` | .cpp 中未 #include 对应 .h | 在使用处 #include |
| **循环包含** | 编译失败或奇怪行为 | A.h #include B.h，B.h #include A.h | 用前置声明（后续 KU 讲解） |
| **忘记头文件卫士** | 重复包含导致重定义 | 多次 #include 同一 .h | 始终使用 `#ifndef` 或 `#pragma once` |

> 💡 **黄金法则**：  
> **“.h 是合同，.cpp 是履约”** —— 合同（声明）可公开，履约（定义）只需做一次。

---

### 🔁 八、螺旋复习

- **前序回顾**：无（这是起点）
- **当日复习**：默写 .h / .cpp 基本结构
- **3 天后**：在学习 1.10（头文件机制）时，回顾本节
- **10 天后**：Phase 1 小测包含头文件错误诊断题

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 Java 不需要 .h 文件？”
   - “如果我把 main 函数放在 .h 里会怎样？”
2. **概念图**：画出 .h / .cpp / 编译器 / 链接器 的关系图
3. **扮演教师**：向朋友解释“为什么 C++ 要分 .h 和 .cpp”

---

### 🔍 十、复盘清单（学习后自测）

✅ 我能说出 .h 和 .cpp 的核心区别  
✅ 我能独立创建多文件项目并成功编译  
✅ 我能解释“重复定义”和“未定义引用”的区别  
✅ 我知道哪些内容**只能**放在 .cpp 中  
✅ 我理解头文件卫士的作用

> 🎯 **达标标准**：完成所有基础题 + 正确分析陷阱题 5

---

## 🚀 下一步建议

你已成功完成 **C++ 转型的第一个原子知识点**！

接下来你可以：
1. **继续学习 1.1.2 预处理阶段（#include、#define）**
2. **请求生成本节的“错题本模板”**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续严谨、高效地推进你的 C++ 之旅！