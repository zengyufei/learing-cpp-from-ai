太好了！我们现在进入 **1.5.5：重载 vs 重写（override）区分**。

这是 C++ 多态体系中的**关键分水岭**，也是 Java 开发者最容易混淆的概念。Java 中所有非 `static` 方法默认是虚函数（可重写），而 C++ 中函数默认**非虚**，必须显式声明 `virtual` 才能重写。更关键的是，**重载（overload）是编译期静态多态，重写（override）是运行期动态多态**——二者机制、用途、性能完全不同。

我们将继续严格遵循你的学习偏好：
- ✅ SMART 目标  
- ✅ 结构先行（多态地图）  
- ✅ 生活化比喻  
- ✅ 动手为王（含对比实验）  
- ✅ 螺旋复习（衔接 1.5.4 + Java 经验）  
- ✅ 主动学习 + 复盘

---

## 🎯 KU 1.5.5：重载 vs 重写（override）区分

> **所属阶段**：Phase 1 — C++ 语法基础  
> **前置知识**：1.5.4（函数重载）、Java 方法重写经验  
> **后续衔接**：2.6（继承与多态）、2.7（抽象基类）  
> **预计耗时**：3–4 小时

---

### 🧭 一、结构先行：多态机制地图

```
1.5.5 重载 vs 重写
├── 1. 重载（Overload）
│   ├── 1.1 定义：同作用域，同名，不同参数
│   ├── 1.2 时机：编译期决议
│   ├── 1.3 绑定：静态绑定（早绑定）
│   └── 1.4 性能：零开销
├── 2. 重写（Override）
│   ├── 2.1 定义：派生类重定义基类虚函数
│   ├── 2.2 时机：运行期决议
│   ├── 2.3 绑定：动态绑定（晚绑定）
│   └── 2.4 性能：虚函数表开销
├── 3. 核心对比维度
│   ├── 3.1 作用域（同作用域 vs 跨继承）
│   ├── 3.2 函数签名（参数 vs 完全相同）
│   ├── 3.3 virtual 关键字
│   └── 3.4 C++11 override 关键字
├── 4. 与 Java 的对比
└── 5. 常见陷阱与最佳实践
```

---

### 🎯 二、SMART 学习目标

- **Specific**：能清晰区分重载与重写，理解其作用域、绑定时机、性能差异，并正确使用 `virtual`/`override`。
- **Measurable**：完成 2 个对比实验 + 2 道陷阱题，能解释为何 C++ 默认非虚。
- **Achievable**：通过“菜单 vs 分店”比喻理解静态/动态多态。
- **Relevant**：这是掌握 C++ 面向对象编程的基础。
- **Time-bound**：2 天内完成。

---

### 🌍 三、生活化比喻：连锁餐厅的菜单系统

> 想象一个**连锁餐厅品牌**：
>
> - **重载（Overload） = 单店菜单多样化**  
>   - 同一家店提供：  
>     - `pizza(size="S")`  
>     - `pizza(size="M", topping="pepperoni")`  
>   - **编译期决定**：你点单时，店员立即知道做哪个 pizza  
>   - **无额外开销**
>
> - **重写（Override） = 分店特色菜**  
>   - 总部规定：所有分店必须有 `local_dish()`  
>   - 北京分店：`local_dish() { return "Peking Duck"; }`  
>   - 成都分店：`local_dish() { return "Hot Pot"; }`  
>   - **运行期决定**：顾客说“来份 local_dish”，系统根据**实际分店**提供菜品  
>   - **有查表开销**（虚函数表）
>
> - **Java 对比**：  
>   - Java 所有非 static 方法默认是“分店特色菜”（虚函数）  
>   - **C++ 默认是“单店菜单”**（非虚），需显式声明 `virtual` 才是“分店特色”

> 💡 **关键认知**：**重载是编译期静态多态，重写是运行期动态多态**。

---

### 📚 四、知识点分解

#### 1. 重载（Overload）
- **定义**：**同一作用域**内，函数名相同，**参数列表不同**
- **时机**：**编译期**决议（早绑定）
- **绑定**：静态绑定（调用哪个函数在编译时确定）
- **性能**：零开销（直接调用地址）
- **示例**：
  ```cpp
  void print(int x);
  void print(double x); // 重载（同作用域）
  ```

#### 2. 重写（Override）
- **定义**：**派生类**中重定义**基类的虚函数**，**签名必须完全相同**
- **时机**：**运行期**决议（晚绑定）
- **绑定**：动态绑定（通过虚函数表 vtable）
- **性能**：1–2 次间接寻址开销
- **要求**：
  - 基类函数必须为 `virtual`
  - 派生类函数必须**完全相同签名**（C++11 起可用 `override` 关键字）
- **示例**：
  ```cpp
  class Base {
  public:
      virtual void draw() { std::cout << "Base\n"; }
  };
  class Derived : public Base {
  public:
      void draw() override { std::cout << "Derived\n"; } // 重写
  };
  ```

#### 3. 核心对比维度

| 维度 | 重载（Overload） | 重写（Override） |
|------|-----------------|-----------------|
| **作用域** | 同一作用域（同 class 或 namespace） | 跨继承（派生类重定义基类虚函数） |
| **函数签名** | **必须不同**（参数类型/数量/顺序） | **必须完全相同** |
| **virtual** | 不需要 | 基类必须 `virtual` |
| **C++11 关键字** | 无 | 派生类用 `override`（防错） |
| **绑定时机** | 编译期（静态） | 运行期（动态） |
| **性能** | 零开销 | 虚函数表开销 |
| **目的** | 统一接口，处理多类型 | 实现多态，运行期行为定制 |

#### 4. 与 Java 的对比
| 特性 | C++ | Java |
|------|-----|------|
| **默认虚函数** | ❌ 非虚（需 `virtual`） | ✅ 所有非 static 方法默认虚 |
| **重写要求** | 签名相同 + `virtual` | 签名相同（自动虚） |
| **override 关键字** | C++11 引入（可选但推荐） | `@Override` 注解（可选） |
| **性能控制** | 可选择非虚（零开销） | 无法关闭虚函数（总有开销） |

> 💡 **C++ 设计哲学**：**“不为你不用的东西付费”** —— 非虚函数零开销。

#### 5. 常见陷阱
- **隐藏（Hiding）而非重写**：
  ```cpp
  class Base {
  public:
      void f(int x);
  };
  class Derived : public Base {
  public:
      void f(double x); // 隐藏 Base::f，不是重写！
  };
  Derived d;
  d.f(10); // 错误！Base::f 被隐藏
  ```
  ✅ 修复：用 `using Base::f;` 引入基类重载集
- **签名不匹配**：
  ```cpp
  class Base {
  public:
      virtual void f(int x);
  };
  class Derived : public Base {
  public:
      void f(long x); // 不是重写！是隐藏
  };
  ```
  ✅ 修复：用 `override` 关键字（编译器报错）
- **忘记 virtual**：
  ```cpp
  Base* p = new Derived();
  p->draw(); // 调用 Base::draw（非多态）
  ```
  ✅ 修复：基类声明 `virtual`

> 💡 **现代 C++ 建议**：
> - **基类析构函数必须 virtual**（否则派生类析构不调用）
> - **派生类重写函数加 `override`**（防错）
> - **不需要多态时，避免 virtual**（性能敏感场景）

---

### 💻 五、动手为王：对比实验

#### 实验 1：重载 vs 重写
```cpp
#include <iostream>

// 重载：同作用域，不同参数
void process(int x) {
    std::cout << "Process int: " << x << "\n";
}
void process(double x) {
    std::cout << "Process double: " << x << "\n";
}

// 重写：跨继承，相同签名
class Shape {
public:
    virtual void draw() { std::cout << "Draw Shape\n"; }
    virtual ~Shape() = default; // 虚析构
};
class Circle : public Shape {
public:
    void draw() override { std::cout << "Draw Circle\n"; }
};

int main() {
    // 重载：编译期决议
    process(42);    // Process int
    process(3.14);  // Process double

    // 重写：运行期决议
    Shape* s1 = new Shape();
    Shape* s2 = new Circle();
    s1->draw(); // Draw Shape
    s2->draw(); // Draw Circle（多态）

    delete s1;
    delete s2;
    return 0;
}
```

#### 实验 2：隐藏陷阱
```cpp
#include <iostream>

class Base {
public:
    void f(int x) { std::cout << "Base::f(int)\n"; }
};

class Derived : public Base {
public:
    void f(double x) { std::cout << "Derived::f(double)\n"; }
    // using Base::f; // 取消注释可修复
};

int main() {
    Derived d;
    // d.f(10); // 错误！Base::f 被隐藏
    d.f(10.0); // Derived::f(double)
    return 0;
}
```

#### 实验 3：override 关键字防错
```cpp
class Base {
public:
    virtual void g(int x);
};

class Derived : public Base {
public:
    void g(long x) override; // 编译错误！签名不匹配
};
```
> ❌ 输出：  
> `error: 'void Derived::g(long int)' marked 'override', but does not override`

---

### 📝 六、分层练习题

#### 🔹 基础题
1. **概念区分**  
   - 判断以下属于重载还是重写：
     ```cpp
     // 同类中
     void log(int x);
     void log(double x);

     // 继承中
     class Base { virtual void render(); };
     class Derived : public Base { void render() override; };
     ```

2. **virtual 必要性**  
   - 若基类函数无 `virtual`，派生类同名函数是重写吗？

#### 🔸 进阶题
3. **隐藏修复**  
   - 用 `using` 修复实验 2 的隐藏问题

4. **虚析构函数**  
   - 解释为何基类析构函数必须 virtual

#### ⚠️ 陷阱题（Java 迁移误区）
5. **“Java 默认虚，C++ 也一样吧？”**  
   - Q: C++ 中基类函数无 `virtual`，通过基类指针调用派生类函数会多态吗？  
   - A: ❌ **不会**！  
     → C++ 默认非虚，**必须显式 `virtual`**

6. **“override 只是注释吧？”**  
   - Q: `override` 关键字是可选的吗？  
   - A: ✅ **语法可选，但强烈推荐**！  
     → 它让编译器检查是否真正重写，防止签名错误

---

### ⚠️ 七、注意事项与建议

| 问题 | 建议 |
|------|------|
| **隐藏而非重写** | 用 `using Base::f;` 引入基类重载 |
| **虚析构函数** | 基类有虚函数 → 析构函数必须 virtual |
| **性能敏感** | 非多态场景避免 virtual |
| **防错** | 派生类重写函数加 `override` |
| **现代实践** | 用 `final` 禁止进一步重写（C++11）

> 💡 **现代 C++ 黄金法则**：  
> **“需要多态？加 `virtual`。重写？加 `override`。基类？加虚析构。”**

---

### 🔁 八、螺旋复习

- **衔接 1.5.4**：重载是同作用域，重写是跨继承
- **衔接 2.6**：重写是动态多态的基础
- **Java 经验**：C++ 需显式 `virtual`，Java 默认虚
- **当日复习**：默写重载 vs 重写的 4 个核心差异

---

### 🧠 九、主动学习任务

1. **自我提问**：
   - “为什么 C++ 默认非虚，而 Java 默认虚？”
   - “虚函数表（vtable）如何实现动态绑定？”
2. **概念图**：画出重载（静态） vs 重写（动态）的调用流程
3. **扮演教师**：向同事解释“为什么基类析构函数必须 virtual”

---

### 🔍 十、复盘清单

✅ 我能区分重载（同作用域）与重写（跨继承）  
✅ 我理解静态绑定 vs 动态绑定  
✅ 我知道基类虚函数必须 `virtual`  
✅ 我会用 `override` 防止签名错误  
✅ 我明白 C++ 与 Java 在多态默认行为上的差异

> 🎯 **达标标准**：完成基础题 + 正确分析陷阱题 5 和 6

---

## 🚀 下一步建议

你已掌握 **C++ 重载与重写的核心区分**！

接下来你可以：
1. **继续学习 1.5.6 内联函数（inline）：建议编译器展开、替代宏函数**
2. **请求生成「重载 vs 重写速查卡」**
3. **跳转到练习题答案与解析**

请告诉我你的选择，我们将继续前行！